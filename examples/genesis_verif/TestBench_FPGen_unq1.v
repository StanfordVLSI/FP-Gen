//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /nobackup/steveri/github/FP-Gen/verif/TestBench_FPGen.vp
//  Source template: TestBench_FPGen
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter DUT 	= Data structure of type FPGen
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/* *****************************************************************************
 * Description:
 * -----------
 * TestBench for FMA
 * 
 * Runtime Arguments 
 * -----------------
 * (Via the "make run RUN=+<runtime_flag[=value]>" notation)
 * * +Wave, +WaveDelay=N, +Seed=N, +NumTrans=N, +SAIF
 * 
 * Parameters:
 * -----------
 * * DUT -- pointer to the design under test object 
 * * NumTrans, Seed
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Oct 05, 2011  shacham   init version - test generator for FP Mult-Acc
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
// DUT (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	InstancePath:top_FPGen.FPGen (FPGen)
//
// TestVectorFile (_GENESIS2_DECLARATION_PRIORITY_) = 
//
// NumTrans (_GENESIS2_DECLARATION_PRIORITY_) = 10
//
// Seed (_GENESIS2_DECLARATION_PRIORITY_) = 0x3039
//


program automatic TestBench_FPGen_unq1 (input logic 				       clk, reset,
			   FPGen_ifc_unq1.Controller FPGen_bus
			   );

   // Local variables and handles for controlling the simulation
   int 								       seed=12345;
   int 								       num_trans = 10;
   int 								       dummy;
   string 							       vector_file = "";
   int 								       verb = 1;
   int 								       result_tag;
   int 								       ignore_errors=0;
   
   
   


   // Local variables and macros for controlling the input file and local memory
   parameter MEM_SIZE = 1000000;
   parameter MEM_WIDTH = 4+256+4+4+4+4+4;

   // Signals for the input testvector verification
   logic [MEM_WIDTH-1:0] 					       Memory [0:MEM_SIZE-1];  // Space for input file
   logic [MEM_WIDTH-1:0] 					       Temp, Temp_q[$], r_Temp;  // Verilog doesn't allow direct access to a

   
   // Singals for read the queues
   logic [63:0] 			       r_a, r_b, r_c;
   logic [63:0] 			       expected, expectedZ;
   logic [2:0] 							       r_rnd;
   
   // queues for storing numbers inside the pipeline
   logic [63:0] 			       a_q[$], b_q[$], c_q[$];
   logic [63:0] 			       expected_q[$];
   

   FPGenControl_unq1  FPControl;
   logic [1:0] 							       opcode_q[$];
   

   logic stall_requested;
   assign stall_requested = FPGen_bus.stall_request;
   
   // FP transaction handles
   FPTransaction_unq1  TransGenA;
   FPTransaction_unq1  TransGenB;
   FPTransaction_unq1  TransGenC;   
   FPTransaction_unq2  TransExpected;

   // one more handle for the observed output
   FPTransaction_unq2  TransRes;

   
   // Reference model
   GoldFMA_unq1  GoldRef;


   // Random model for forwarding signal
   forward_unq1  ForwardA;
   forward_unq1  ForwardB; 
   forward_unq1  ForwardC;
   logic							       forward_a_q[$], forward_b_q[$];
   logic [0:0] 				       forward_c_q[$];
   
   

   //-------------------------------------------------------------------------//
   // MAIN: Main flow of test
   //-------------------------------------------------------------------------//
   initial begin
      get_command_line_args();
      start_up_testbench();

      // Fork the driver and monitor to do their thing
      fork
	 start_saif();
	 drive_dut();
	 monitor_dut();
      join
      
      // if we reached this point safely, the test passed!
      repeat (10) @(negedge clk); // give the lines some time to settle
      $display("%t: TESTBENCH IS DONE -- \033[0;32mTEST PASS\033[0m", $time);
      result_tag = $fopen("TEST_PASS","w");
      $fclose(result_tag);
      
      finish_saif();
      $finish(0);
   end
   

   
   //-------------------------------------------------------------------------//
   // start_up_testbench: Task to reset all DUT signals and testbench objects
   //-------------------------------------------------------------------------//
   task start_up_testbench;
      $display("%t: TESTBENCH IS ALIVE -- STARTING INITIALIZATION...",$time);
      // some simulation control initialization
      dummy = $urandom(seed);
      TransGenA = new();
      TransGenB = new();
      TransGenC = new();
      TransExpected = new();
      TransRes = new();
      GoldRef = new();
      ForwardA = new();
      ForwardB = new();
      ForwardC = new();
      $display("%t: TESTBENCH IS ALIVE (SEED=%d) -- NOW RUNNING %d TESTS...", $time, seed, num_trans);
      // some simulation wire values initialization
      //FPGen_bus.dumptolog = 1'b0;
      FPGen_bus.stall_in = 1'b0;
      FPGen_bus.opcode = FPGenPkg::FMADD;
      FPControl = new();
      FPGen_bus.a = 0;
      FPGen_bus.b = 0;
      FPGen_bus.c = 0;
      FPGen_bus.rnd = 3'b000;
      FPGen_bus.forward_a = 1'b0;
      FPGen_bus.forward_b = 1'b0;
      FPGen_bus.forward_c = 0;
   endtask // start_up_testbench
   

   //-------------------------------------------------------------------------//
   // Driver: every cycle, on the neg edge generate stimulus	
   //-------------------------------------------------------------------------//
   task drive_dut;
      int loc;
      @(posedge reset);
      @(negedge clk);
      #1;
      
      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 int i=0;
	 while (i<num_trans) begin
	    if(!stall_requested) begin
               FPControl.randomize();
               FPGen_bus.opcode = FPControl.opcode;
	       i++;
	       
	       // Assign values to the lines
	       // FPGen_bus.dumptolog = 1'b0;
	       ForwardA.randomize();
	       ForwardB.randomize();
	       ForwardC.randomize();
	       
	       if ( ForwardA.forward
		    // check the if there is result in pipeline for forwarding
		    && i > 5 ) begin
		  FPGen_bus.forward_a = 1'b1;
		  TransGenA.ForceFPNum( expected_q[0]);
	       end 
	       else  begin
		  FPGen_bus.forward_a = 1'b0;
		  TransGenA.randomize();
	       end // else: !if( ForwardA.forward...
	       // store the forward_a signal in the queue
	       forward_a_q = {forward_a_q, FPGen_bus.forward_a};

               if ( ForwardB.forward
		    // check the if there is result in pipeline for forwarding
		    && i > 5 ) begin
		  FPGen_bus.forward_b = 1'b1;
		  TransGenB.ForceFPNum( expected_q[0]);
	       end 
	       else  begin
		  FPGen_bus.forward_b = 1'b0;
		  TransGenB.randomize();
	       end // else: !if( ForwardB.forward...
	       // store the forward_b signal in the queue
	       forward_b_q = {forward_b_q, FPGen_bus.forward_b};

               if ( (|ForwardC.forward)
		    // check the if there is result in pipeline for forwarding
		    && i > 5 ) begin
		  FPGen_bus.forward_c = ForwardC.forward;
                  if (0+ForwardC.hotbit < 0)
                    TransGenC.ForceFPNum(expectedZ);
                  else
		    TransGenC.ForceFPNum(expected_q[0+ForwardC.hotbit]);
	       end 
	       else  begin
		  FPGen_bus.forward_c = 0;
		  TransGenC.randomize();
	       end // else: !if( ForwardC.forward...
	       // store the forward_a signal in the queue
	       forward_c_q = {forward_c_q, FPGen_bus.forward_c};
	       

	       // drive data bus
               FPGen_bus.a = TransGenA.GetFPNum();
               FPGen_bus.b = TransGenB.GetFPNum();	
	       FPGen_bus.c = TransGenC.GetFPNum();

	       // store all the numbers in queques
	       a_q = {a_q, FPGen_bus.a};
	       b_q = {b_q, FPGen_bus.b};
	       c_q = {c_q, FPGen_bus.c};
	       
	       opcode_q = {opcode_q, FPGen_bus.opcode};

	       // now calculate results
	       
	       // HACK overwrite b or c for adder and mul mode
               if (FPControl.opcode == FPGenPkg::FADD)
                 TransGenB.ForceFPNum({ 2'b0, {(10){1'b1}}, 52'b0 });
	       if (FPControl.opcode == FPGenPkg::FMUL)
                 TransGenC.ForceFPNum(0);


	       
	       // calculate the expected result
	       GoldRef.CalcGold(TransGenA, TransGenB, TransGenC, FPGen_bus.rnd);
	       expected = GoldRef.Expected.GetFPNum();
	       // store results in queques
	       expected_q = {expected_q, expected};
	       
	    end
	    @(negedge clk);#1;		// wait a clock cycle
    	 end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	 $readmemh (vector_file, Memory);
	 loc=0;
	 Temp = Memory[loc];
	 Temp_q = {Temp_q, Temp};
	 while((loc < MEM_SIZE) && !(Temp == 1'bx) ) begin	    
	    if(!stall_requested) begin
	       FPGen_bus.opcode = FPGenPkg::FMADD;
	       FPGen_bus.rnd = Temp[277:276];
	       FPGen_bus.a = Temp[275:212];
	       FPGen_bus.b = Temp[211:148];
	       FPGen_bus.c = Temp[147:84];	    
	       loc = loc + 1;
	       Temp = Memory[loc];
	       Temp_q = {Temp_q, Temp};
	    end
	    @(negedge clk); #1;		// wait a clock cycle
	 end // while (loc <MEM_SIZE && MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
   endtask // drive_dut
   
   
   
   //-------------------------------------------------------------------------//
   // Monitor: every clk*$pipeline_depth+clk*k, check results	
   //-------------------------------------------------------------------------//
   task monitor_dut;
      @(posedge reset);
      @(negedge clk);
      repeat(6) begin
	 @(negedge clk);
	 // while stall_requested is enable, wait another cycle
	 while(stall_requested) @(negedge clk);
      end
      
      // @(negedge clk); 

      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 int i=0;
	 while (i<num_trans) begin
	    if(!stall_requested) begin
	       i++;
	       if (verb) begin
		  $display("\n%t: Transaction #%0d: ", $time, i);	  
		  $display("%t opcode: %2b", $time, opcode_q[0]);
	       end
	       
	       // set the input numbers and dequeque
	       r_a = a_q[0];
	       r_b = b_q[0];
	       r_c = c_q[0];
	       expectedZ = expected_q[0];
	       a_q = a_q[1:$];
	       b_q = b_q[1:$];
	       c_q = c_q[1:$];
	       expected_q = expected_q[1:$];
	       opcode_q = opcode_q[1:$];
	       
	       // restore FP models
	       TransRes.ForceFPNum(FPGen_bus.z);
	       TransGenA.ForceFPNum(r_a);
	       TransGenB.ForceFPNum(r_b);
	       TransGenC.ForceFPNum(r_c);
	       TransExpected.ForceFPNum(expectedZ);
	     
	       // Print the forwarding information
	       if(verb) begin
		  if ( forward_a_q[0] )
		    $display("%t A is forwarded from Transaction #%0d", $time, i-5);
		  if ( forward_b_q[0] )
		    $display("%t B is forwarded from Transaction #%0d", $time, i-5);
		  if ( |forward_c_q[0] ) begin
		     // find the hotbit in forward_c_q[0]
		     int hotbit;
		     for (int k=0; k<=0; k++) begin
			if (forward_c_q[0][k]) begin
			   hotbit=k;
			end
		     end
		     $display("%t C is forwarded from Transaction #%0d", $time, i-5+hotbit);
		  end
	       end
	       // dequeque
	       forward_a_q = forward_a_q[1:$];
	       forward_b_q = forward_b_q[1:$];
	       forward_c_q = forward_c_q[1:$];
	       
	       // now check results...
	       if ( !ignore_errors   &&  !GoldRef.CheckMultResult(TransRes, TransExpected) ) begin
		  //FPGen_bus.dumptolog = 1'b1;
		  #1;	      
		  // Print some transaction information
		  $display( "%t: SENT:   TypeA=%s SignA=%b ExpA=0x%h FracA=0x%h", $time,
			    TransGenA.TransType.name(), TransGenA.Sign, TransGenA.Exponent, TransGenA.Fraction);
		  $display( "%t:         TypeB=%s SignB=%b ExpB=0x%h FracB=0x%h", $time,
			    TransGenB.TransType.name(), TransGenB.Sign, TransGenB.Exponent, TransGenB.Fraction);
		  $display( "%t:         TypeC=%s SignC=%b ExpC=0x%h FracC=0x%h", $time,
			    TransGenC.TransType.name(), TransGenC.Sign, TransGenC.Exponent, TransGenC.Fraction);  
		  $display( "%t: EXPECTED: Type=%s Sign=%1b Exp=0x%h Frac=0x%h", $time,
			    TransExpected.TransType.name(), TransExpected.Sign, TransExpected.Exponent, TransExpected.Fraction);
		  $display( "%t: FOUND:   Type=%s Sign=%b Exp=0x%h Frac=0x%h", $time,
			    TransRes.TransType.name(), TransRes.Sign, TransRes.Exponent, TransRes.Fraction);
		  $display("%t: %hx%h+%h = %h (%h) WRONG", $time, r_a, r_b, r_c, FPGen_bus.z, expectedZ);
		  $display("%t: \033[0;31mERROR Found\033[0m", $time);
		  result_tag = $fopen("TEST_FAIL","w");
		  $fclose(result_tag);
                  @(negedge clk); #1;		// wait a clock cycle
		  $finish(2);
	       end
	       else begin
		  // Print some transaction information
		  if (verb) begin
		  $display( "%t: SENT:   TypeA=%s SignA=%b ExpA=0x%h FracA=0x%h", $time,
			    TransGenA.TransType.name(), TransGenA.Sign, TransGenA.Exponent, TransGenA.Fraction);
		  $display( "%t:         TypeB=%s SignB=%b ExpB=0x%h FracB=0x%h", $time,
			    TransGenB.TransType.name(), TransGenB.Sign, TransGenB.Exponent, TransGenB.Fraction);
		  $display( "%t:         TypeC=%s SignC=%b ExpC=0x%h FracC=0x%h", $time,
			    TransGenC.TransType.name(), TransGenC.Sign, TransGenC.Exponent, TransGenC.Fraction);  
		  $display( "%t: EXPECTED: Type=%s Sign=%1b Exp=0x%h Frac=0x%h", $time,
			    TransExpected.TransType.name(), TransExpected.Sign, TransExpected.Exponent, TransExpected.Fraction);
		  $display( "%t: FOUND:   Type=%s Sign=%b Exp=0x%h Frac=0x%h", $time,
			    TransRes.TransType.name(), TransRes.Sign, TransRes.Exponent, TransRes.Fraction);
		  $display("%t: %hx%h+%h = %h (%h) Checked", $time, r_a, r_b, r_c, FPGen_bus.z, expectedZ);
		  end // if (verb)
	       end 
	    end
            @(posedge clk);		// wait a clock cycle
    	 end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	 r_Temp = Temp_q[0];
  	 Temp_q = Temp_q[1:$];
	 while( !(r_Temp == 1'bx) ) begin
	    
	    if(!stall_requested) begin	      
	       // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
	       logic   FX, FO, FU, FV, FZ, expectNaN, expectIsZero, resultIsZero;
	       
	       expectedZ = r_Temp[83:20];
	       FO = r_Temp[12];
	       FZ = r_Temp[0];
	       FV = r_Temp[4];
	       FU = r_Temp[8];
	       FX = r_Temp[16];
	       r_rnd = r_Temp[277:276];
	       r_a = r_Temp[275:212];
	       r_b = r_Temp[211:148];
	       r_c = r_Temp[147:84];
	       
	       expectNaN = expectedZ[62:52] ==	{(11){1'b1}} 
		       && expectedZ[51:0]!={(52){1'b0}};
	       expectIsZero = expectedZ[62:52] == {(11){1'b0}} 
		       && expectedZ[51:0]=={(52){1'b0}};
	       
	       /*
		if(FO) begin
		expectedZ[62:0] = {{(11){1'b1}},{(52){1'b0}}};
	    end
		if(FU) begin
		expectedZ[62:0] = {(63){1'b0}};
	    end
		*/

	       if (verb) begin
		  $display("\n\n%t: Input: %h_%h_%h_%h ( %e * %e + %e = %e )", $time,
			   r_rnd, r_a, r_b, r_c, $bitstoreal(r_a),  $bitstoreal(r_b), 
			   $bitstoreal(r_c), $bitstoreal(expectedZ));
		  // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
		  $display("%t: Expect Result: \tSign = %h, Exp = %h, Man = %h, FO=%h FU=%h FV=%h FX=%h FZ=%h, NaN=%b", $time,
			   expectedZ[63], expectedZ[62:52], expectedZ[51:0],FO, FU, FV, FX, FZ, expectNaN);
		  $display("%t: FMA_Result: \tSign = %h, Exp = %h, Man = %h", $time,
			   FPGen_bus.z[63], FPGen_bus.z[62:52], FPGen_bus.z[51:0]);
	       end
	       
	       /*
		//calculate output result after inc
    		TransRes.ForceFPNum(z);
		TransRes.CalculateInc();
		z2 = TransRes.GetFPNum();
		$display("%t: After Inc: Sign = %h, Exp = %h, Man = %h  ", $time,
		z2[63], z2[62:52], z2[51:0] );
		*/

	       
	       resultIsZero = FPGen_bus.z[62:52] == {(11){1'b0}} 
			      && FPGen_bus.z[51:0]=={(52){1'b0}};
	       if (!ignore_errors) begin
		  if(!(FPGen_bus.z == expectedZ || (resultIsZero==1 && expectIsZero==1)
		       /* && !(FO==1 && status[1]==1) && !(FU==1 && (status[0]|status[3]==1))*/
		       || (expectNaN==1 && (FPGen_bus.status[2]==1)))) begin
		     //FPGen_bus.dumptolog = 1'b1;
		     #1;
		     $display("%t: \033[0;31mERROR Found\033[0m", $time);
		     result_tag = $fopen("TEST_FAIL","w");
		     $fclose(result_tag);
		     $finish(2);
		  end
	       end
	       r_Temp = Temp_q[0];
  	       Temp_q = Temp_q[1:$];
	    end
	    @(negedge clk);
	 end // while ( MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
   endtask // monitor_dut
   


   
   //-------------------------------------------------------------------------//
   // general runtime argument parsing procedure
   //-------------------------------------------------------------------------//
   task get_command_line_args;
      int 	wave=0;
      int 	wave_delay=0;
      // if this is a "+wave" run, it must record all signals      
      if ( $test$plusargs("Silent") ) begin
	 $display("\t%t:\tRuntime input +Silent found",$time);
	 verb = 0;
      end
      if ( $test$plusargs("Wave") ) begin
         $display("\t%t:\tRuntime input Wave found (will start signal capture soon...)",$time);
	 wave = 1;
      end
      if ( $test$plusargs("WaveDelay") ) begin
	 $value$plusargs("WaveDelay=%d", wave_delay);
	 $display("\t%t:\tRuntime input +WaveDelay=%0d found. Waveform will be recorded from the %0dth Transaction",$time, wave_delay, wave_delay);
      end      
      // Run wave if wave=1
      fork
	 if (wave) start_wave(.wave_delay(wave_delay));
      join_none
      
      // find the seed for this run
      if ( $test$plusargs("Seed") ) begin
	 $value$plusargs("Seed=%d", seed);
	 $display("\t%t:\tRuntime input +Seed=%d found",$time, seed);
      end
      if ( $test$plusargs("NumTrans") ) begin
	 $value$plusargs("NumTrans=%d", num_trans);
	 $display("\t%t:\tRuntime input +NumTrans=%d found",$time, num_trans);
      end
      if ( $test$plusargs("IgnoreErrors") ) begin
	 $display("\n\t%t:\tWARNING IgnoreErrors was set -- all checks are disabled\n",$time);
	 ignore_errors = 1;
      end
      if ( $test$plusargs("File") ) begin
	 $value$plusargs("File=%s", vector_file);
	 $display("\t%t:\tRuntime input +File=%s found",$time, vector_file);
      end
   endtask // get_command_line_args


   // task to control wave capture
   task start_wave(input int wave_delay=0);
      if(wave_delay)	
	repeat(wave_delay) @(posedge clk);
      $display("\t%t:\tStarting signal and memory wave capture",$time);
      $vcdpluson(   0  , top_FPGen);
   endtask // start_wave

   
   // Activity factor tasks
   task start_saif;
      if ( $test$plusargs("SAIF") ) begin
         $display("\t%t:\tStarting SAIF (Switching Activity Interchange Format)",$time);
	 // setup SAIF: https://solvnet.synopsys.com/retrieve/029417.html
	 $set_gate_level_monitoring("on", "mda");
      	 $set_toggle_region(top_FPGen.FPGen);
	 // wait for sim to really start
	 @(posedge reset);
	 $toggle_start;
      end
   endtask // start_saif

   task finish_saif;
      if ( $test$plusargs("SAIF") ) begin
         $display("\t%t:\tFinalizing SAIF (Switching Activity Interchange Format)",$time);
	 $toggle_stop();
	 $toggle_report ("FPGen.saif",1.0e-12,top_FPGen.FPGen);
      end
   endtask // finish_saif
   
endprogram : TestBench_FPGen_unq1
