/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/FMA_Exp.vp#1 $
 ** $DateTime: 2011/12/24 22:02:13 $
 ** $Change: 9979 $
 ** $Author: sameh06 $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * FMA Exponent datapath
 *  
 * 
  * Parameters:
 * * FractionWidth, ExponentWidth, EnableDenormals
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Jan 24, 2012   sameh06   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the Fraction for the multiplier (default is IEEE Double, 52 bit)");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the exponent for the multiplier (default is IEEE Double, 11 bit)");
//; my $enable_denormals = parameter(Name=>'EnableDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO)");
//;
//; # And some local variables
//; my $product_width = 2 * $frac_width + 2;
//; my $wide_width = 4 * $frac_width  + 7; # 1 sign bit + (frac_width+1) + 2 guard bits + (2*frac_width+2) + (frac_width+1)
//; my $shift_width = CeilOfLog2($wide_width);
//; my $lza_width = $wide_width - $frac_width - 1;
//; my $lza_enc_width = CeilOfLog2($lza_width) + 1;
//; my $SHIFT_CONST = $frac_width + 4; # frac_width+1 for fraction, 2 for separator bit, 1 for the extra digit before fractional bit
//; my $BIAS = sprintf("{(%d){1'b1}} ", $exp_width-1);
//;


module `mname` (
   //; if ($verif_mode =~ /ON/){
    input  logic dumptolog,
   //; }
    input  logic [`$exp_width-1`:0]  ExpA, ExpB, ExpC,
    input  logic denormA, denormB, denormC, ZeroC, IncExp, denormResult, ResultExactZero,
    input  logic [`$lza_enc_width-1`:0] LshiftAmt, 
    output logic [`$shift_width-1`:0] RshiftAmt,
    output logic [`$lza_width-1`:0] lza_override_mask,
    output logic [`$exp_width-1`:0] ExpResult,
    output logic FV //overflow flag
                 );

  logic [`$exp_width-1`:0] ExpResult1;
  logic [`$exp_width+1`:0] pre_shift, ExpSum, ExpCarry, ExpAB, ExpBase, RshiftSum, RshiftCarry, RshiftInitial, ExpResult0, ExpResult0_b;
  logic ExpUnderflow, ExpResultIsC;
  logic DummyCo1, DummyCo2, DummyCo3, DummyCo4, DummyCo5, DummyCo6, DummyCo7;

  /* base exponent calculation
     ExpBase = ExpResultIsC? ExpC : ExpA + ExpB - BIAS + SHIFT_CONST;
  */     
  assign pre_shift = `$SHIFT_CONST` -`$BIAS`; 
  DW01_csa #(`$exp_width+2`) CSA0 (.a({2'b0,ExpA}),.b({2'b0,ExpB}),.c(pre_shift),.ci(denormA | denormB), 
                                         .carry(ExpCarry), .sum(ExpSum), .co(DummyCo1) );
  assign ExpAB = ExpSum + ExpCarry;
  assign ExpBase = ExpResultIsC? {2'b0,ExpC} : ExpAB;
        
  /*RshiftAmt calculation
    RshiftAmt = ExpA + ExpB - ExpC - BIAS + SHIFT_CONST
    and has a maximum of 225 and minimum of 0, therefore we need to sign extend it by 2 bits to correctly determine the shift amount
  */

  DW01_csa #(`$exp_width+2`) CSA1(.a({2'b11,~ExpC}), .b(ExpCarry), .c(ExpSum), .ci(~denormC),
                                  .carry(RshiftCarry),.sum(RshiftSum),.co(DummyCo2));
  assign RshiftInitial = RshiftSum + RshiftCarry;
  assign ExpResultIsC = RshiftInitial[`$exp_width+1`] & ~ZeroC; //no right shift and C is not zero
  assign RshiftAmt = ExpResultIsC?
                         8'b0:
                         (RshiftInitial[`$exp_width`:`$shift_width`]==0) ?
                               RshiftInitial[`$shift_width-1`:0] :
                               {(`$shift_width`){1'b1}};





  /*MaxLshiftAmt calculation 
    This calculation is only relevant if right shift has occured, which means the minimum resulting exponent will be 1
    ------------------- 
    1 =  ExpBase - MaxLShiftAmt
    MaxLShiftAmt = ExpBase - 1

  */

  wire [(1<<`$shift_width`)-1 : 0] max_shift_dec;

  DW_decode_en #(`$shift_width`) U1 ( .en(~|ExpBase[`$exp_width`:`$shift_width`])    // Disable if the exponent is big enough
                                 , .a(ExpBase[`$shift_width-1`:0])
                                 , .b(max_shift_dec) );

  //assign max_shift_mask= {max_shift_dec[manB_width+1:2],max_shift_dec[1] | max_shift_dec[0]};
  assign lza_override_mask[`$lza_width-1`] = max_shift_dec[1] | max_shift_dec[0] | ExpBase[`$exp_width+1`]; //The mask has one at Expbase - 1 position
  

//; for (my $i=0 ; $i<$lza_width-1 ; $i++){
  assign lza_override_mask[`$i`] = max_shift_dec[`$lza_width-$i`];//max_shift_dec[manB_width-i+1]; 
//; }


  /*Exponent Calculation
	  
    ExpResult0 = ExpBase - LshiftAmt
  */

  assign ExpResult0 = ExpBase - LshiftAmt;
  assign ExpResult1 = ExpResult0+1;
  assign ExpResult = ExpUnderflow? {(`$exp_width`){1'b0}}: (IncExp ? ExpResult1 : ExpResult0);
        
  assign ExpUnderflow = denormResult | ExpResult0[`$exp_width+1`];

  /* Overflow flags
  */

  assign FV =  !ExpResult0[`$exp_width+1`]
                   & ( ExpResult0[`$exp_width`] || (ExpResult0[`$exp_width-1`:1]== {(`$exp_width-1`){1'b1}} & (IncExp | ExpResult0[0])) ) ;

//; if ($verif_mode =~ /ON/){
    // synopsys translate_off
    always @(posedge dumptolog)
    begin
      $display ("pre_shift=%h ExpAB=%h", pre_shift, ExpAB);
      $display ("ExpResult=%b",ExpResult);
      $display ("IncExp=%b",IncExp);
      $display ("ExpResultIsC=%b",ExpResultIsC);
      $display ("FVExp=%b", FV);
      $display ("lza_override_mask=%b", lza_override_mask);
     $display ("ExpBase=%b", ExpBase);
    end
    // synopsys translate_on
//; }

endmodule
