/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a multiplier that uses a parametrized booth and parametrized 
 * summation tree.
 * 
 * Parameters:
 * * Width, BoothType, TreeType
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 04, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; my $DW_mode = parameter(Name=>'Designware_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"!IMPLEMENTATION! Designware mode determines whether or not ".
//;                                 "designware codes are used instead of our ".
//;                                 "design.");
//; my @incOpts ;
//; $DW_mode eq 'ON'  and @incOpts = ['NO'] ;
//; $DW_mode eq 'OFF' and @incOpts = ['YES','NO'] ;
//;
//; # Interface parameter
//; my $useInc = parameter(Name=>'UseInc', Val=>'', List=>@incOpts,
//; 			  Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; $useInc = ($useInc =~ /YES/)? 1:0;
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>53, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths !FUNCTIONAL!");
//;
//;


module `mname`(
   //; if ($verif_mode =~ /ON/){
    input logic dumptolog,
   //; }
    input logic [`$width-1`:0]    a,b,
   //; if ($useInc){
    input logic 		  ainc, binc,
   //; }
    output logic [`2*$width-1`:0] out		  
		    );

//; if( $DW_mode eq 'ON' ){
 
   DW02_mult #( `$width` , `$width` )
   U1 ( .A(a), .B(b), .TC( 1'b0 ), .PRODUCT(out) );
   
//; } elsif( $DW_mode eq 'OFF' ){


/* SUM/CARRY MULTIPLIER */
   
   logic [`2*$width+1`:0] 	  multp_out0,multp_out1; // sign extended by 2 because of booth encoding
   //; my $Mul_obj = generate('MultiplierP', 'MultP', Width=>$width, UseInc=>($useInc)?"YES":"NO");
   `$Mul_obj->instantiate()` 
     (
      //; if ($verif_mode =~ /ON/){
       .dumptolog(dumptolog),
      //; }
      .a(a), .b(b), 
      //; if ($useInc){
      .ainc(ainc), .binc(binc),
      //; }
      .out0(multp_out0), .out1(multp_out1)
      );


/* FINAL SUMMATION */
   
   //; my $adderInst = generate( 
   //;                            'adder'  ,  
   //;                            'PartialProductSum'   , 
   //;                            BitWidth=>2*$width  ,
   //;                            Orientation=>'L' ,
   //;                            GroupName=>'PartialProductSum' 
   //;                          );
   `$adderInst->instantiate()` (   
				   .a(  multp_out0[`2*$width-1`:0]  ) , 
				   .b(  multp_out1[`2*$width-1`:0]  ) , 
				   .ci(1'b0) , 
				   .s(  out  ) 
			       ); 
//; #end $DW_mode eq 'OFF'
//; } else {
//;   self->error( "Not a legal case" ) ;
//; }
endmodule

