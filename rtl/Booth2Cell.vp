/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/Booth2Enc.vp#2 $
 ** $DateTime: 2011/10/14 10:59:50 $
 ** $Change: 9603 $
 ** $Author: shacham $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Booth TWO encoding for a multiplier.
 * 
 * Booth encoder produce the partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 2 encoder
 * 
 * Y[2:0]     out  =  pp   +   S
 * 
 * 0 0 0      +0      100000  +0      
 * 0 0 1      +X      (10X)   +0
 * 0 1 0      +X      (10X)   +0
 * 0 1 1      +2X     (1X0)   +0
 * 1 0 0      -2X     (0~X1)  +1
 * 1 0 1      -X      (01~X)  +1
 * 1 1 0      -X      (01~X)  +1
 * 1 1 1      -0      011111  +1
 * 
 * NOTE: There is 1 to be augmented to the left of the partial products 
 *       excepf for the first one
 * 
 * 
 * 
 * Parameters:
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 23, 2011   sameh     Booth 2 mux
 * ****************************************************************************/


//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level

module `mname` (
   input [1:0]    x, x_b,
   input [1:0]    y_edge_vector,  // y_edge_vector[i] = y[i]!=y[i+1]
   input          y_msb,          // y[2]
   output out );
   
   logic x_temp;

   assign x_temp = (y_edge_vector[0] & x[1]) | (!y_edge_vector[0] & y_edge_vector[1] & x[0]);
   assign out = x_temp ^ y_msb;

// Example Synthesis Result
//-------------------------
//  INVD1BWPLVT U1 ( .I(y_edge_vector[0]), .ZN(n4) );
//  AOI32D1BWPLVT U2 ( .A1(x[0]), .A2(n4), .A3(y_edge_vector[1]), .B1(x[1]), .B2(y_edge_vector[0]), .ZN(n5) );
//  XNR2D2BWPLVT U3 ( .A1(n5), .A2(y_msb), .ZN(out) );

endmodule
