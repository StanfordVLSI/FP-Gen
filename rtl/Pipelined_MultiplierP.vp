/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/Pipelined_MultiplierP.vp#7 $
 ** $DateTime: 2012/03/13 09:19:10 $
 ** $Change: 10257 $
 ** $Author: jbrunhav $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Forward Pipelined Multiplier that keeps out in carry save format
 * Positive pipelinde depth is used to insert pipeline stages while negative
 * ones are used to create parallel pumped multiplier using clock gating 
 *
 * Parameters:
 * * Width, BoothType, TreeType, PipelineDepth
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 04, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math

//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off.  !IGNORE!" ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off. !IGNORE! ");
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # Interface parameter
//; my $useInc = parameter(Name=>'UseInc', Val=>'YES', List=>['YES', 'NO'],
//; 			   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc)");
//; my $useMP = parameter(Name=>'UseMP', Val=>'YES', List=>['YES', 'NO'],
//; 			  Doc=>"Multi precision mode: Treat inputs as 2 numbers and produce 2 results.");
//; my $multP_module_name = ($useMP =~ /YES/)? 'MultiplierP_MP':'MultiplierP';
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>53, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths  !FUNCTIONAL!");
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>-4,
//;                       Doc=>"Pipeline depth !FUNCTIONAL!");
//;

   
module `mname`(

    input logic [`$width-1`:0] 	  a,b,
    input logic 		  clk , rst, stall,
//; if ($useMP=~ /YES/){
    input logic                   mp_mode,
//; }	       
//; if ($useInc=~ /YES/){
    input logic 		  ainc, binc,
//; }	    
    output logic [`2*$width+1`:0] out0,out1, // sign extended by 2 because of booth encoding
    output logic stall_out
		    );

//; if ($pipeline_depth==0){
//;   my $Mul_obj = generate($multP_module_name, 'MultP', Width=>$width, UseInc=>$useInc);

   `$Mul_obj->instantiate()` (

      .a(a), .b(b),
//;   if ($useMP=~ /YES/){
      .mp_mode(mp_mode),
//;   } 
//;   if ($useInc=~ /YES/){
      .ainc(ainc), .binc(binc),
//;   }
      .clk(clk) , .rst(rst),
      .out0(out0), .out1(out1)
      );
//; } elsif ($pipeline_depth>0){

   logic [`$width-1`:0] a_0,b_0;
   logic stall_0;      
//;   if ($useInc=~ /YES/){
   logic ainc_0, binc_0;
//;   }
//;   if ($useMP=~ /YES/){
   logic mp_mode_0;
//;   }
   logic [`2*$width+1`:0] multp_out0, multp_out1; // sign extended by 2 because of booth encoding

//;   if ($useInc=~ /YES/){
//;      if ($useMP=~ /YES/){
//;        my $pipein = generate(  'FF_pipeline',  'Mult_pipein',  Width=> 2*$width+3 , PipelineDepth=>1, Retime=>"NO");
   `$pipein ->instantiate()` ( .in({a, ainc, b, binc,mp_mode}) , .stall_in(stall), .clk(clk) , .reset(rst), 
                               .out({a_0, ainc_0, b_0, binc_0,mp_mode_0}), .stall_out(stall_0) );
//;      } else {
//;        my $pipein = generate(  'FF_pipeline',  'Mult_pipein',  Width=> 2*$width+2 , PipelineDepth=>1, Retime=>"NO");
   `$pipein ->instantiate()` ( .in({a, ainc, b, binc}) , .stall_in(stall), .clk(clk) , .reset(rst), .out({a_0, ainc_0, b_0, binc_0}), .stall_out(stall_0) );
//;      }
//;   } else {
//;      if ($useMP=~ /YES/){
//;        my $pipein = generate(  'FF_pipeline',  'Mult_pipein',  Width=> 2*$width+1 , PipelineDepth=>1, Retime=>"NO");
   `$pipein ->instantiate()` ( .in({a, b,mp_mode}) , .stall_in(stall), .clk(clk) , .reset(rst), 
                               .out({a_0, b_0,mp_mode_0}), .stall_out(stall_0) );
//;      } else {
//;        my $pipein = generate(  'FF_pipeline',  'Mult_pipein',  Width=> 2*$width , PipelineDepth=>1, Retime=>"NO");
   `$pipein ->instantiate()` ( .in({a, b}) , .clk(clk) , .stall_in(stall), .reset(rst), .out({a_0, b_0}), .stall_out(stall_0) );
//;      }
//;   }
//;   my $Mul_obj = generate($multP_module_name, 'MultP', Width=>$width, UseInc=>$useInc);
   `$Mul_obj->instantiate()` (
      .a(a_0), .b(b_0),
//;   if ($useMP=~ /YES/){
      .mp_mode(mp_mode),
//;   } 
//;   if ($useInc=~ /YES/){
      .ainc(ainc_0), .binc(binc_0),
//;   }
      .clk(clk) , .rst(rst),
      .out0(multp_out0), .out1(multp_out1)
      );
//;   if ($pipeline_depth>1){
//;     my $pipeout = generate(  'FF_pipeline',  'Mult_pipeout',  Width=> 4*$width+4 , PipelineDepth=>$pipeline_depth-1, Retime=>"YES");
    `$pipeout ->instantiate()` ( .in({multp_out1,multp_out0}) , .stall_in(stall_0), .clk(clk) , .reset(rst), .out({out1,out0}), .stall_out(stall_out) );
//;   }
//; } else {

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
   set_dont_retime [current_design] true
   set_optimize_registers false -design [current_design]
  */

    reg [`-$pipeline_depth-1`:0] enable;
    logic [`-$pipeline_depth-1`:0] next_enable;

    assign next_enable = {enable[0], enable[`-$pipeline_depth-1`:1]};

    DW03_pipe_reg #(`-$pipeline_depth`,1) dff_stall ( .A(stall) , .clk(clk) , .B(stall_out) ) ;

    always @(negedge clk)
      if (rst)
        enable <= 1;
      else
        enable <= next_enable;

//;   for (my $i=0; $i<-$pipeline_depth; $i++){
   logic [`$width-1`:0] a_`$i`,b_`$i`;       
//;     if ($useInc=~ /YES/){
   logic ainc_`$i`, binc_`$i`;
//;     }
//;     if ($useMP=~ /YES/){
   logic mp_mode_`$i`;
//;     }

    always @(posedge clk)
    if (enable[`$i`] & !stall)
    begin
      a_`$i`<=a;
      b_`$i` <= b;
//;     if ($useInc=~ /YES/){
      ainc_`$i` <= ainc;
      binc_`$i` <= binc;
//;     }
//;     if ($useMP=~ /YES/){
      mp_mode_`$i`<=mp_mode;
//;     }
    end

   logic [`2*$width+1`:0] multp`$i`_out0, multp`$i`_out1; // sign extended by 2 because of booth encoding
//;     my $Mul_obj = generate($multP_module_name, "MultP_${i}", Width=>$width, UseInc=>$useInc);

   `$Mul_obj->instantiate()` (
      .a(a_`$i`), .b(b_`$i`),
//;     if ($useMP=~ /YES/){
      .mp_mode(mp_mode_`$i`),
//;     }
//;     if ($useInc=~ /YES/){
      .ainc(ainc_`$i`), .binc(binc_`$i`),
//;     }
      .clk(clk) , .rst(rst),
      .out0(multp`$i`_out0), .out1(multp`$i`_out1)
      );

//;   }

  always_comb
    unique case (1'b1)
//;   for (my $i=0; $i<-$pipeline_depth; $i++){
       enable[`$i`]: {out1,out0} = {multp`$i`_out1,multp`$i`_out0};
//;   } 
    endcase
//; }

endmodule

