/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * Booth THREE encoding for a multiplier.
 * 
 * Booth encoder produce the partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 3 encoder
 * 
 * Y[4:0]       y_edge_vec     out  =  pp   +  S
 * 	                  
 * 0 0 0 0 0    -0000          +0      100..0  0      
 * 0 0 0 0 1    -0001          +X      1000X   0      
 * 0 0 0 1 0    -0011          +X      1000X   0
 * 0 0 0 1 1    -0010          +2X     100X0   0
 * 0 0 1 0 0    -0110          +2X     100X0   0
 * 0 0 1 0 1    -0111          +3X     10X3    0
 * 0 0 1 1 0    -0101          +3X     10X3    0
 * 0 0 1 1 1    -0100          +4X     10X00   0
 * 0 1 0 0 0    -1100          +4X     10X00   0      
 * 0 1 0 0 1    -1101          +5X     1X5     0      
 * 0 1 0 1 0    -1111          +5X     1X5     0
 * 0 1 0 1 1    -1110          +6X     1X30    0
 * 0 1 1 0 0    -1010          +6X     1X30    0
 * 0 1 1 0 1    -1011          +7X     1X7     0
 * 0 1 1 1 0    -1001          +7X     1X7     0
 * 0 1 1 1 1    -1000          +8X     1X000   0
 * 1 0 0 0 0    -1000          -8X     0~X111  1      
 * 1 0 0 0 1    -1001          -7X     0~X7    1      
 * 1 0 0 1 0    -1011          -7X     0~X7    1
 * 1 0 0 1 1    -1010          -6X     0~X31   1
 * 1 0 1 0 0    -1110          -6X     0~X31   1
 * 1 0 1 0 1    -1111          -5X     0~X5    1
 * 1 0 1 1 0    -1101          -5X     0~X5    1
 * 1 0 1 1 1    -1100          -4X     01~X11  1
 * 1 1 0 0 0    -0100          -4X     01~X11  1
 * 1 1 0 0 1    -0101          -3X     01~X31  1
 * 1 1 0 1 0    -0111          -3X     01~X31  1
 * 1 1 0 1 1    -0110          -2X     011~X1  1
 * 1 1 1 0 0    -0010          -2X     011~X1  1
 * 1 1 1 0 1    -0011          -X      0111~X  1
 * 1 1 1 1 0    -0001          -X      0111~X  1
 * 1 1 1 1 1    -0000          -0      011..1  1
 * 
 * 
 * 
 * 
 * NOTE: there is 1 to be augmented to the left of the partial products 
 *       except for the first one
 * 
 * 
 * Parameters:
 * -----------
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 06, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>1, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");



module `mname` (
    input logic [`$width-1`:0] 	x, 
    input logic [`$width+1`:0] 	x3, 
    input logic [`$width+2`:0] 	x5,x7, 
    input logic [3:0] 		y_edge_vector,		// y_edge_vector[i] = y[i]==y[i+1]
    input logic 		y_msb,                 	// y[3]
    output logic [`$width+3`:0] pp,               	//extend width by four: 1 bit for sign and three for shifting to get 8X
    output logic 		S
		);
   
   /* TO ME:
    * See booth 3 for reasoning about order of muxing.
    * */

   logic [`$width+5`:0] 	x_padded;
   logic [`$width+3`:0] 	x3_padded;
   
   assign x_padded = {3'b0, x, 3'b0};
   assign x3_padded = {1'b0, x3, 1'b0};
   assign S = y_msb;
   
   logic 			sel_x1;
   assign sel_x1 = (~y_edge_vector[3] & ~y_edge_vector[2] & y_edge_vector[0]); // yedge = 00x1 ==> +/-X
   
   logic 			sel_x2;
   assign sel_x2 = (~y_edge_vector[3] & y_edge_vector[1] & ~y_edge_vector[0]); // yedge = 0x10 ==> +/-2X 
   
   logic 			sel_x3;
   assign sel_x3 = (~y_edge_vector[3] & y_edge_vector[2] & y_edge_vector[0]); // yedge = 01x1

   logic 			sel_x4;
   assign sel_x4 = (y_edge_vector[2] & ~y_edge_vector[1] & ~y_edge_vector[0]); // yedge = x100 ==> +/-4X
   
   logic 			sel_x5;
   assign sel_x5 = (y_edge_vector[3] & y_edge_vector[2] & y_edge_vector[0]); // yedge = 11x1 ==> +/-5X
   
   logic 			sel_x6;
   assign sel_x6 = (y_edge_vector[3] & y_edge_vector[1] & ~y_edge_vector[0]); // yedge = 1x10 ==> +/-6X

   logic 			sel_x7;
   assign sel_x7 = (y_edge_vector[3] & ~y_edge_vector[2] & y_edge_vector[0]); // yedge = 10x1 ==> +/-7X

   logic 			sel_x8;
   assign sel_x8 = (y_edge_vector[3] & ~y_edge_vector[2] & ~y_edge_vector[1] & ~y_edge_vector[0]); // yedge = 1000 ==> +/-8X



   /* *****
    * Now, for each bit in the pp we need to do the muxing as folows:
    * 
    *  for $i in 3 to $width+6 begin
    *    Mux 0, x, 2x, 4x based on the edge vector
    *    assign pp01248[$i-3] = (sel_x1 & x_padded[$i]) | (sel_x2 & x_padded[$i-1]) | (sel_x4 & x_padded[$i-2]) | (sel_x8 & x_padded[$i-3]);
    *    
    *    Mux pp0124, 3x, x5, 6x, 7x, 8x 
    *    assign pp012345678[$i-3] = (sel_x3 & x3_padded[$i-2]) | (sel_x5 & x5[$i-3]) | (sel_x6 & x3_padded[$i-3]) | (sel_x7 & x7[$i-3])  | pp01248[$i-3];
    *    
    *    Select pp or pp_b based on sign
    *    assign pp[$i-3] = pp012345678[$i-3] ^ S; // invert if S=1
    *  end for loop
    * *****/
   
   //; for (my $i=3; $i<$width+6; $i++){
   // Instantiate cell for pp bit `$i-3`
   //;   my $BoothCell_obj = generate('BoothCell', "cell_$i", BoothType=>4);
   `$BoothCell_obj->instantiate` 
     	(.sel_x1(sel_x1),.sel_x2(sel_x2),.sel_x3(sel_x3),.sel_x4(sel_x4), 
	 .sel_x5(sel_x5),.sel_x6(sel_x6),.sel_x7(sel_x7),.sel_x8(sel_x8),
	 .x1(x_padded[`$i`]), .x2(x_padded[`$i-1`]), .x3(x3_padded[`$i-2`]), .x4(x_padded[`$i-2`]), 
	 .x5(x5[`$i-3`]), .x6(x3_padded[`$i-3`]), .x7(x7[`$i-3`]), .x8(x_padded[`$i-3`]),
	 .y_msb(y_msb), .pp(pp[`$i-3`]));
   
   //; }
   assign pp[`$width+3`] = ~S;
   
   //; if ($verif_mode =~ /ON/){
   always @(*) begin
      #1;
      assert ($onehot({sel_x1,sel_x2,sel_x3,sel_x4,sel_x5,sel_x6,sel_x7,sel_x8}) || 
	      {sel_x1,sel_x2,sel_x3,sel_x4,sel_x5,sel_x6,sel_x7,sel_x8} == 8'b0 || !$time)else begin
	 $display("%t: ERROR: Bad select signals for booth4 cell: select=%8b", $time, {sel_x1,sel_x2,sel_x3,sel_x4,sel_x5,sel_x6,sel_x7,sel_x8});
	 $finish(2);
      end
   end
   //; }

endmodule : `mname`
