/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * Booth THREE encoding for a multiplier.
 * 
 * Booth encoder produce the partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 3 encoder
 * 
 * Y[3:0]     y_edge_vec    out  =  pp   +   S
 * 	                  
 * 0 0 0 0    -000          +0      100000   +0      
 * 0 0 0 1    -001          +X      (100X)   +0
 * 0 0 1 0    -011          +X      (100X)   +0
 * 0 0 1 1    -010          +2X     (10X0)   +0
 * 0 1 0 0    -110          +2X     100000   +0      
 * 0 1 0 1    -111          +3X     (1X3)    +0
 * 0 1 1 0    -101          +3X     (1X3)    +0
 * 0 1 1 1    -100          +4X     (1X00)   +0
 * 1 0 0 0    -100          -4X     (0~X11)  +1      
 * 1 0 0 1    -101          -3X     (0~X3)   +1
 * 1 0 1 0    -111          -3X     (0~X3)   +1
 * 1 0 1 1    -110          -2X     (01~X1)  +1
 * 1 1 0 0    -010          -2X     (01~X1)  +1
 * 1 1 0 1    -011          -X      (011~X)  +1
 * 1 1 1 0    -001          -X      (011~X)  +1
 * 1 1 1 1    -000          -0      011111   +1
 * 
 * NOTE: there is 1 to be augmented to the left of the partial products 
 *       except for the first one
 * 
 * 
 * Parameters:
 * -----------
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 06, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>1, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");



module `mname` (
    input logic [`$width-1`:0] 	x, x_b,
    input logic [`$width+1`:0] 	x3, x3_b,
    input logic [2:0] 		y_edge_vector,		// y_edge_vector[i] = y[i]==y[i+1]
    input logic 		y_msb,                 	// y[3]
    output logic [`$width+2`:0] pp,               	//extend width by two: 1 bit for sign and second for shifting for 2X multiple
    output logic 		S
		);
   
   /* TO ME:
    * X3 and X3_b are late signals. Therefore, rather than muxing {0,x,2x,3x,4x,4x_b,3x_b,2x_b,x_b} 
    * we will first mux x vs. x_b (assign it to x_out), then we'll mux {0,x_out, 2x_out, 4x_out} (assign 
    * it to pp0124) and then mux {pp0124, x3, x3_b}. Capiche?
    * */

/*******************************************************************************
 * Simpler implementation. However it does not give us control on placing of
 * each booth3cell.
 * *****************************************************************************
   // Mux x and x_b based on sign
   logic [`$width-1`:0] 	x_out;
   assign S = y_msb;
   assign x_out = S ? x_b: x;

   logic [`$width+2`:0]   pp0124;
   

    always_comb
     begin
	// Mux 0, x_out, 2x_out, 4x_out based on the edge vector
	unique case (y_edge_vector)
	  // 3'b000:  	pp0124 = {~S,{(`$width+2`){S}}};	// yedge = 000 ==> 0 
  	  3'b001,3'b011:pp0124 = {~S,S,S,x_out};		// yedge = 0X1 ==> +/-X     
  	  3'b010,3'b110:pp0124 = {~S,S,x_out,S};		// yedge = X10 ==> +/-2X 
  	  3'b100:	pp0124 = {~S,x_out,S,S};		// yedge = 100 ==> +/-4X
	  default: pp0124 = {~S,{(`$width+2`){S}}};
        endcase // case (y_edge_vector)
  
   
	// Mux pp0124, 3x, 3x_b based on the edge vector and sign
	unique case ({(y_edge_vector[2] & y_edge_vector[0]),S})
	  2'b10:  pp = {~S,x3};                       
	  2'b11:  pp = {~S,x3_b};
	  //2'b00, 2'b01:  pp = pp0124;
	  default: pp = pp0124;
	endcase
     end
 *******************************************************************************/ 

   logic [`$width+3`:0] 	x_padded;
   logic [`$width+1`:0] 	pp0124;
   logic [`$width+1`:0] 	pp01234;
   
   assign x_padded = {2'b0, x, 2'b0};
   assign S = y_msb;
   
   logic 			sel_x;
   assign sel_x = (~y_edge_vector[2] & y_edge_vector[0]); // yedge = 0X1 ==> +/-X
   
   logic 			sel_x2;
   assign sel_x2 = (y_edge_vector[1] & ~y_edge_vector[0]); // yedge = X10 ==> +/-2X 
   
   logic 			sel_x3;
   assign sel_x3 = y_edge_vector[2] & y_edge_vector[0];

   logic 			sel_x4;
   assign sel_x4 = (y_edge_vector[2] & ~y_edge_vector[1] & ~y_edge_vector[0]); // yedge = 100 ==> +/-4X
   
   //; for (my $i=2; $i<$width+4; $i++){
   // Mux 0, x, 2x, 4x based on the edge vector
   assign pp0124[`$i-2`] = (sel_x & x_padded[`$i`]) | (sel_x2 & x_padded[`$i-1`]) | (sel_x4 & x_padded[`$i-2`]);
 
   // Mux pp0124, 3x based on the edge vector
   assign pp01234[`$i-2`] = (sel_x3 & x3[`$i-2`]) | (~sel_x3 & pp0124[`$i-2`]);

   // Select pp or pp_b based on sign
   assign pp[`$i-2`] = pp01234[`$i-2`] ^ S; // invert if S=1
   //; }
   assign pp[`$width+2`] = ~S;
   
 
endmodule : `mname`
