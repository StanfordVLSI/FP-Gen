/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * Booth THREE encoding for a multiplier.
 * 
 * Booth encoder produce the partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 3 encoder
 * 
 * Y[3:0]     y_edge_vec    out  =  pp   +   S
 * 	                  
 * 0 0 0 0    -111          +0      100000   +0      
 * 0 0 0 1    -110          +X      (100X)   +0
 * 0 0 1 0    -100          +X      (100X)   +0
 * 0 0 1 1    -101          +2X     (10X0)   +0
 * 0 1 0 0    -001          +2X     100000   +0      
 * 0 1 0 1    -000          +3X     (1X3)    +0
 * 0 1 1 0    -010          +3X     (1X3)    +0
 * 0 1 1 1    -011          +4X     (1X00)   +0
 * 1 0 0 0    -011          -4X     (0~X11)  +1      
 * 1 0 0 1    -010          -3X     (0~X3)   +1
 * 1 0 1 0    -000          -3X     (0~X3)   +1
 * 1 0 1 1    -001          -2X     (01~X1)  +1
 * 1 1 0 0    -101          -2X     (01~X1)  +1
 * 1 1 0 1    -100          -X      (011~X)  +1
 * 1 1 1 0    -110          -X      (011~X)  +1
 * 1 1 1 1    -111          -0      011111   +1
 * 
 * NOTE: there is 1 to be augmented to the left of the partial products 
 *       except for the first one
 * 
 * 
 * Parameters:
 * -----------
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 06, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>1, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");



module `mname` (
    input logic [`$width-1`:0] 	x, x_b,
    input logic [`$width+1`:0] 	x3, x3_b,
    input logic [2:0] 		y_edge_vector,		// y_edge_vector[i] = y[i]==y[i+1]
    input logic 		y_msb,                 	// y[3]
    output logic [`$width+2`:0] pp,               	//extend width by two: 1 bit for sign and second for shifting for 2X multiple
    output logic 		S
		);
   

   logic [`$width-1`:0]   x_out;
  

   assign S = y_msb;
   assign x_out = S ? x_b: x;

  /*
  reg [width+2:0] softPP;
  always @*
  begin
    case (y[3:0])
       4'b0000,4'b1111: softPP = {~S,{(width+2){S}}};            // 0      (y[0]==y[1]==y[2]==y[3])    
       4'b0001,4'b0010,4'b1101,4'b1110: softPP = {~S,S,S,x_out}; // +/-X   (y[0]!=y[1]) & (y[2]==y[3])
       4'b0011,4'b1100,4'b0100,4'b1011: softPP = {~S,S,x_out,S}; // +/-2X  (y[0]==y[1]) & (y[1]!=y[2])
       4'b0101,4'b0110,4'b1001,4'b1010: softPP = {~S,x3_out};    // +/-3X  (y[0]!=y[1]) & (y[2]!=y[3]) 
       4'b1000,4'b0111: softPP = {~S,x_out,S,S};                 // +/-4X  (y[0]==y[1]==y[2]) & (y[2]!=y[3])
    endcase
  end

  assign pp = softPP;
  */
   logic [`$width+2`:0] 	  pp0124;
   logic [1:0] 		  mux_control;

   assign mux_control = {(y_edge_vector[1] | y_edge_vector[0]) ,  ((y_edge_vector[2] & ~y_edge_vector[1]) | y_edge_vector[0]) };
   
   always_comb
     begin
	case (mux_control)
	  2'b00:  pp0124 = {~S,{(`$width+2`){S}}};              // 0      (y[0]==y[1]==y[2]==y[3])           //yedge = 000
  	  2'b01:  pp0124 = {~S,x_out,S,S};                      // +/-4X  (y[0]==y[1]==y[2]) & (y[2]!=y[3])  //yedge = 100
  	  2'b10:  pp0124 = {~S,S,x_out,S};                      // +/-2X  (y[0]==y[1]) & (y[1]!=y[2])        //yedge = X10
  	  2'b11:  pp0124 = {~S,S,S,x_out};                      // +/-X   (y[0]!=y[1]) & (y[2]==y[3])        //yedge = 0X1
        endcase
    
	casex ({(y_edge_vector[0] | y_edge_vector[2]),S})
	  2'b00:  pp = {~S,x3};                       
	  2'b01:  pp = {~S,x3_b};
	  2'b1x:  pp = pp0124;
	endcase
     end
  

/*  assign pp = y_edge_vector[0] ?
                    (y_edge_vector[2] ?  {~S,x3_out} : {~S,S,S,x_out})
                   :(y_edge_vector[1] ?  {~S,S,x_out,S}: y_edge_vector[2]? {~S,x_out,S,S} : {~S,{(width+2){S}}} );*/
 
endmodule : `mname`
