
/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/CMA.vp#1 $
 ** $DateTime: 2011/12/24 22:02:13 $
 ** $Change: 9979 $
 ** $Author: sameh06 $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * FMA datapath
 * Status flag bits
 * ______________________________
 * Bit| Flag      | Description
 * ______________________________
 *  0 | Zero      | Integer or floating point output is zero.
 *  1 | Infinity  | Floating point output is infinity.
 *  2 | Invalid   | Floating point operation is not valid (0x∞, ∞-∞ ) . It is also set to 1 when one of the inputs is NaN
 *  3 | Tiny      | Non zero floating point output after rounding has a magnitude less than the minimum normalized number( a denormalized number)
 *  4 | Huge      | Finite floating point result after rounding has a magnitude greater than the maximum normalized number.
 *  5 | Inexact   | Integer or floating point output is not equal to the infinitely precise result.
 * ______________________________
 *  
 * 
 * Parameters:
 * ------------
 * * FractionWidth, ExponentWidth, EnableDenormals, useInc
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Jan 24, 2012   sameh06   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil floor log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off." ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.");
//; my $desinware_mode = parameter(Name=>'Designware_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Designware mode determines whether or not ".
//;                                 "designware codes are used instead of our ".
//;                                 "design.");

//;
//; # module parameters
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"!FUNCTIONAL! Width of the Fraction for the multiplier (default is IEEE Double, 52 bit)");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"!FUNCTIONAL! Width of the exponent for the multiplier (default is IEEE Double, 11 bit)");
//; my $enable_denormals = parameter(Name=>'EnableDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO)");
//;
//; my $enable_forwarding = parameter(Name=>'EnableForwarding', Val=>'YES', List=>['YES', 'NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//;
//; my $pipeline_depth = parameter( Name=>'PipelineDepth', Val=>8 , Min=>(($enable_forwarding =~ /YES/)?5:0), Max=>20,
//;                                 Doc=>"!FUNCTIONAL! Pipeline depth" );
//; my $muladd_pipeline_depth = ($enable_forwarding =~ /YES/ && $pipeline_depth>0) ? $pipeline_depth-1 : $pipeline_depth ;
//; my $default_mul_pipeline_depth = floor(4*$muladd_pipeline_depth /7);
//; my $min_mul_pipeline_depth = ($enable_forwarding =~ /YES/) ? 2 : 0 ;
//; if ( $default_mul_pipeline_depth < $min_mul_pipeline_depth) {
//;   $default_mul_pipeline_depth = $min_mul_pipeline_depth;
//; }
//; my $mul_pipeline_depth = parameter(Name=>'MulPipelineDepth', Val=>$default_mul_pipeline_depth, Min=>$min_mul_pipeline_depth, Max=> $muladd_pipeline_depth  ,
//;                       Doc=>"Multiplier Part Pipeline depth");
//; my $add_pipeline_depth = $muladd_pipeline_depth-$mul_pipeline_depth;
//; parameter(Name=>'AddPipelineDepth', Val=>$add_pipeline_depth, Min=>$add_pipeline_depth, Max=> $add_pipeline_depth,
//;                       Doc=>"Adder Part Pipeline depth");
//;
//; # And some local variables
//; my $product_width = 2 * $frac_width + 2;
//; my $ExtendedExp_width = $exp_width + 2;
//;


module `mname` (
   //; if ($verif_mode =~ /ON/){
    input logic 				dumptolog,
   //; }
    input logic [`$exp_width+$frac_width`:0] 	a, b, c,
    input logic [2:0] 				rnd,

  //; if ($enable_forwarding =~ /YES/){
    input logic 				forward_a, forward_b,
    input logic [`$mul_pipeline_depth`:0] 	forward_c, 
  //; }
    input logic 				clk , reset,
   //; if ($pipeline_depth>0){
    input logic 				valid_in, adder_mode, multiplier_mode, stall_in, SI, SCAN_ENABLE, test_mode,
    output logic 				valid_out, SO, stall_request,
   //; }
    output logic [`$exp_width + $frac_width`:0] z,
    output logic [7:0] 				status
   );


  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */

  logic SignAB, NANAB, InfAB, ZeroAB, RStickyAB, ResultIsClose, ExpB_gt_ExpA, SignC, ExpABInc;
  logic [`$ExtendedExp_width-1`:0] ExpDifference, ExpAB;
  logic [`$product_width-1` : 0] ManAB;
  logic [`$ExtendedExp_width-1` : 0] ExpC_pp0_init, ExpC_pp1_init, ExpC_pp0, ExpC_pp1, ExpZ_pp0, ExpZ_pp1, ExpZ_pp0_late, ExpZ_pp1_late;
  logic ExpC_ci_init, ExpC_ci, ExpZ_ci, ExpZ_ci_late;
  logic [`$exp_width-1` : 0] ExpC;
  logic stall, SignC_init, ExpCdec, ExpCDecrementWhenShifting, ExpZDecrementWhenShifting, ExpZDecrementWhenShifting_late, valid_ExpA, SignC_2, valid_c, valid_ExpC, IncC, IncC2, IncZ, IncZm, ZeroExpC, valid_rnd;
  logic valid_mul, valid_add, ShiftZ, ShiftC, ShiftC2, SignZ;
  logic [`$mul_pipeline_depth-1`:0] forward_c_out, forward_c_out_dummy;

  logic [`$exp_width + $frac_width`:0] z_preInc, z_preIncm, c2, forwarded_c;
  logic [7:0] status_init;
  logic [2:0] rnd_add;

//; if ($pipeline_depth>0){
  assign stall = stall_request | stall_in;
//; }

//; my $CascadeMUL_obj = generate('FPMult', 'MUL', FractionWidth=>$frac_width 
//;                                              , ExponentWidth=>$exp_width
//;                                              , EnableDenormals=>$enable_denormals
//;                                              , FloatingDigits => 2
//;                                              , EnableForwarding => $enable_forwarding,
//;                                              , PipelineDepth => $mul_pipeline_depth );
  `$CascadeMUL_obj->instantiate()` (
//;      if ($verif_mode =~ /ON/){
                                  .dumptolog(dumptolog),
//;      }
                                  .a_in(a), .b_in(b),
//;      if ($enable_forwarding =~ /YES/){
                                  .forward_a(forward_a), .forward_b(forward_b),	
                                  .z_preInc(z_preInc), .IncZ(IncZ), .z_postInc(z),
//;      }
//;      if ($mul_pipeline_depth>0){
                                  .valid_in(valid_in), .clk(clk) , .stall_in(stall_in), .reset(reset),
                                  .valid_out(valid_mul), .stall_request(stall_request), .adder_mode(adder_mode), .multiplier_mode(multiplier_mode),
//;      }
                                  .SignAB_out(SignAB), .ExpAB_out(ExpAB) , .ManAB_out(ManAB),
                                  .NANAB_out(NANAB), .InfAB_out(InfAB), .ZeroAB_out(ZeroAB)

                                  );

//; if ($pipeline_depth>0 && $mul_pipeline_depth==0){
    assign valid_mul = valid_in;
   assign stall_request = 1'b0;
   
//; }

assign ZeroExpC = ~| c[ `$exp_width + $frac_width - 1` :`$frac_width` ]; 
assign ExpC  = { c[ `$exp_width + $frac_width - 1` :`$frac_width + 1` ] , ZeroExpC | c[`$frac_width`] }; 

//; if ($enable_forwarding =~ /YES/){
  assign { ExpC_pp0_init, ExpC_pp1_init, ExpC_ci_init, ExpCdec} = forward_c[0]?
                     {ExpZ_pp0_late , ExpZ_pp1_late , ExpZ_ci_late, ExpZDecrementWhenShifting_late} 
                   : {2'b0, ExpC, {(`$exp_width+2`){1'b1}} , 2'b0};
//; } else  {
  assign { ExpC_pp0_init, ExpC_pp1_init, ExpC_ci_init, ExpCdec} = {2'b0, ExpC, {(`$exp_width+2`){1'b1}} , 2'b0};
//; }


//; if ($mul_pipeline_depth>0) {
//;   my $pipe_forward = generate(  'FF_pipeline',  'pipe_exp_forward',
//;                              Width=> 2*$ExtendedExp_width+2,
//;                              PipelineDepth => $mul_pipeline_depth, Retime=>'NO',
//;                              EnableForwarding => $enable_forwarding);
  `$pipe_forward->instantiate()` ( .in({ExpC_pp0_init, ExpC_pp1_init, ExpC_ci_init, ExpCdec}) ,
//;     if ($enable_forwarding =~ /YES/) {
                               .forwarded_in({ExpZ_pp0, ExpZ_pp1, ExpZ_ci, ExpZDecrementWhenShifting}),
                               .forward(forward_c[`$mul_pipeline_depth`:1]),
                               .forward_out (forward_c_out),
//;     }
                               .valid_in(valid_in), .clk(clk) , .stall(stall), .reset(reset), 
                               .out({ExpC_pp0, ExpC_pp1, ExpC_ci, ExpCDecrementWhenShifting}),
                               .valid_out(valid_ExpC) );


//;   my $pipe_forward2 = generate(  'FF_pipeline',  'pipe_c_forward',
//;                              Width=> $exp_width+$frac_width+3,
//;                              PipelineDepth => $mul_pipeline_depth, Retime=>'NO',
//;                              EnableForwarding => $enable_forwarding);
  `$pipe_forward2->instantiate()` ( .in({c, 2'b0}) ,
//;     if ($enable_forwarding =~ /YES/) {
                               .forwarded_in({z_preInc,IncZ, ShiftZ}),
                               .forward(forward_c[`$mul_pipeline_depth-1`:0]),
                               .forward_out (forward_c_out_dummy),
//;     }
                               .valid_in(valid_in), .clk(clk) , .stall(stall), .reset(reset), 
                               .out({c2, IncC2, ShiftC2}),
                               .valid_out(valid_c) );

//;   my $pipe_forward3 = generate(  'FF_pipeline',  'pipe_rnd_forward',
//;                              Width=> 3,
//;                              PipelineDepth => $mul_pipeline_depth, Retime=>'NO');
  `$pipe_forward3->instantiate()` ( .in(rnd) ,.valid_in(valid_in), .clk(clk) , .stall(stall), .reset(reset), 
                               .out(rnd_add), .valid_out(valid_rnd) );
//; } else {
  assign {ExpC_pp0, ExpC_pp1, ExpC_ci, ExpCDecrementWhenShifting} = {ExpC_pp0_init, ExpC_pp1_init, ExpC_ci_init, ExpCdec};
  assign {c2, IncC2, ShiftC2} = {c, 2'b0};
  assign rnd_add = rnd;
//; }

//; if ($enable_forwarding =~ /YES/){
  assign {forwarded_c, IncC, ShiftC} = forward_c_out[`$mul_pipeline_depth-1`]? {z_preInc,IncZ, ShiftZ}: {c2, IncC2, ShiftC2};
//; } else {
  assign {forwarded_c, IncC, ShiftC} = {c2, IncC2, ShiftC2};
//; }
  assign SignC    = forwarded_c[ `$exp_width + $frac_width` ];



//; my $ED_obj = generate('ExponentDifference', 'ED', ExponentWidth=>$exp_width);
  `$ED_obj->instantiate()` (.ExpA_pp0(ExpC_pp0), .ExpA_pp1(ExpC_pp1), .ExpA_ci(ExpC_ci),
                .ExpADecrementWhenShifting(ExpCDecrementWhenShifting), .SignA(SignC), .ShiftA(ShiftC), 
                .ExpB(ExpAB), .SignB(SignAB), .ExpDifference(ExpDifference), .ResultIsClose(ResultIsClose), .ExpB_gt_ExpA(ExpB_gt_ExpA)
  //; if ($verif_mode =~ /ON/){
              , .dumptolog(dumptolog)
  //; }
                            );



//; my $CascadeADD_obj = generate('FPAdd', 'ADD', FractionWidth=>$frac_width 
//;                                             , ExponentWidth=>$exp_width
//;                                             , EnableDenormals=>$enable_denormals
//;                                             , EnableForwarding => $enable_forwarding,
//;                                             , PipelineDepth => $add_pipeline_depth );

  `$CascadeADD_obj->instantiate()` (
//;   if ($verif_mode =~ /ON/){
                        .dumptolog(dumptolog),
//;   }
                        .A(forwarded_c),
//;   if ($enable_forwarding =~ /YES/) {
                        .IncA(IncC),
//;   }
                        .SignB(SignAB), .ExpB(ExpAB), .ManB(ManAB), .InfB(InfAB), .NANB(NANAB), .ZeroB(ZeroAB),
                        .rnd(rnd_add),
                        .ExpDifference(ExpDifference), .ResultIsClose(ResultIsClose), .ExpB_gt_ExpA(ExpB_gt_ExpA),
                        .ExpZ_pp0(ExpZ_pp0), .ExpZ_pp1(ExpZ_pp1), .ExpZ_ci(ExpZ_ci),
                        .ExpZ_pp0_late(ExpZ_pp0_late), .ExpZ_pp1_late(ExpZ_pp1_late), .ExpZ_ci_late(ExpZ_ci_late),
                        .ExpZDecrementWhenShifting(ExpZDecrementWhenShifting), .ExpZDecrementWhenShifting_late(ExpZDecrementWhenShifting_late),
                        .ShiftZ(ShiftZ),
//;   if ($add_pipeline_depth>0){
                        .valid_in(valid_mul), .clk(clk) , .stall(stall), .reset(reset),
                        .valid_out(valid_add),
//;   } 
                        .Z(z_preInc), .IncZ(IncZ), .status(status_init)
                        );

//; if ($add_pipeline_depth==0){
  assign valid_add = valid_mul;
//; }


//; if ($enable_forwarding =~ /YES/) {
//;    my $inc_pipe = $enable_forwarding =~ /YES/?
//;           generate('Pinned_pipeline','inc_pipe', Width=> $exp_width + $frac_width + 10 , PipelineDepth=> 1)
//;          :generate('FF_pipeline','inc_pipe', Width=> $exp_width + $frac_width + 10 , PipelineDepth=> 1, Retime=> 'YES');
  `$inc_pipe ->instantiate()` (
       .in({z_preInc,IncZ, status_init}) , 
       .valid_in(valid_add), .clk(clk) , .stall(stall), .reset(reset), 
       .out({z_preIncm,IncZm,status}),
       .valid_out(valid_out) );
//; }  else {
  assign {z_preIncm,IncZm,status} = {z_preInc,IncZ, status_init};
//; }

//;  my $fma_increment = generate('FPIncrementer','Incrementer', FractionWidth=> $frac_width , ExponentWidth=> $exp_width );

  `$fma_increment->instantiate()` (
   //; if ($verif_mode =~ /ON/){
    .dumptolog(dumptolog),
   //; }
    .a(z_preIncm), .ainc(IncZm), .out(z) );
	
endmodule

