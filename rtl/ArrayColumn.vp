/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/ArrayColumn.vp#4 $
 ** $DateTime: 2011/10/06 15:10:49 $
 ** $Change: 9561 $
 ** $Author: sameh $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a ArrayColumn that process a vertical slice in multiplication tree 
 * using a linear array architecture
 *
 * Parameters:
 * * ColumnHight, ColumnPosition, MinRow, BoothType, CarryInWidth, LayoutShape
 * 
 * Exported Parameters:
 * * CarryOutWidth
 *
 * Inputs:
 * * ColumnHight pp                 
 * * CarryInWidth ci
 *  
 * Outputs:
 * * sum
 * * carry
 * * CarryOutWidth co
 *
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; # use POSIX qw(floor ceil); # For floor and ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters

//; my $col_ht = parameter(Name=>'ColumnHight', Val=>2, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products in relevant column to sum");
//; my $col = parameter(Name=>'ColumnPosition', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The column number");
//; my $min_row = parameter(Name=>'MinRow', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The starting row position");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $ci_w = parameter(Name=>'CarryInWidth', Val=>0, Min=>0, Step=>1,
//;                      Doc=>"Number of carry in from previous column");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; # Also notify everyone how many carry out you will have
//; my $co_w = ($min_row==0)? $col_ht-3 : $col_ht-2;
//; parameter(Name=>'CarryOutWidth', Val=>$co_w, Force=>1, Min=>0, Step=>1,
//;           Doc=>"Number of carry out to next column");


module `mname()` (
    input logic [`$col_ht-1`:0] pp,
//; if($ci_w){
    input logic  [`$ci_w-1`:0] ci,
//; }
//;if($co_w){
    output logic [`$co_w-1`:0] co,
//;}
    output logic sum, carry
   );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */

   //; my $inter_sum_w = ($min_row==0)? $col_ht-3 : $col_ht-2;
   logic [`$inter_sum_w`:0] inter_sum;
   logic [`$co_w`:0] 	      inter_co;
   
   //; # is num_pp here one less then in previous column?
   //; my $going_down_col = 0;
   //; if ($booth==1){
   //;   $going_down_col = ($min_row>0)? 1:0;
   //; }else{
   //;   $going_down_col  = ($min_row>0 && $col%$booth==1)? 1:0;
   //; }
   //; ## print STDERR "DEBUG: going_down_col=$going_down_col min_row=$min_row, col=$col, booth=$booth\n";
   //;
   //; # local variables for index etc.
   //; my $row = $min_row;
   //; my $Y = $col;
   //; my $pp_idx = 0; my $sum_idx = 0;
   //; my $ci_idx = 0; my $co_idx = 0;
   //;
   //; while (($pp_idx < $col_ht) || ($ci_idx < $ci_w)){
   //;
   //;   # Determine the physical location for the CSA/HA cell
   //;   $Y = $col - $row * $booth if $layout_shape =~ /Square/;
   //;   $Y = $col if $layout_shape =~ /Parallelogram/;
   //;
   //;   # Check if we need to stick an extra pp into the first csa of the column
   //;   my $one_extra_pp = ($row==$min_row)? 1:0;
   //;   my $two_extra_pp = ($one_extra_pp && !$going_down_col && $col_ht>2)? 1:0;
   //;
   //;   # Check if we need a full or half adder
   //;   my $need_full = (($col_ht-$pp_idx) + ($ci_w-$ci_idx) + ($inter_sum_w-$sum_idx) >= 3)? 1:0;
   //;   $self->error("How can I need tow extra pp and only half adder?") if $two_extra_pp && !$need_full;
   //; 
   //;   if ($two_extra_pp && $need_full){
   //;     my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // No inter_sum or carry_in to the first CSA so use all inputs for pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(pp[`$pp_idx++`]), .ci(pp[`$pp_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;   }
   //;   elsif ($one_extra_pp && $need_full){
   //;     my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // No inter_sum to the first CSA so use a second input for pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(pp[`$pp_idx++`]), .ci(ci[`$ci_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;   }
   //;   elsif ($one_extra_pp && !$need_full){
   //;     my $CSA_obj = generate('HA', "ha_${row}_${Y}");
   // No inter_sum or carry_in to the first HA so use both inputs for pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(pp[`$pp_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;   }
   //;   elsif ($need_full){
   //;     my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // Regular case: pp, inter_sum and ci
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(inter_sum[`$sum_idx++`]), .ci(ci[`$ci_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;   }
   //;   else{
   //;     my $CSA_obj = generate('HA', "ha_${row}_${Y}");
   //;     if ($pp_idx < $col_ht){
   // Just a half adder to add the last pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(inter_sum[`$sum_idx++`]),
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;     }else{
   // Just a half adder to add the last ci
   `$CSA_obj->instantiate()` ( .a(inter_sum[`$sum_idx++`]), .b(ci[`$ci_idx++`]),
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;     }
   //;   }
   //;   $row++;
   //; } # End of "while (..."

   //; $self->error("How come ci_idx($ci_idx)!=ci_w($ci_w) or pp_idx($pp_idx)!=col_ht($col_ht)") unless $ci_idx==$ci_w && $pp_idx==$col_ht;
   assign sum = inter_sum[`$sum_idx`];
   assign carry = inter_co[`$co_w`];
   //;if($co_w){
   assign co = inter_co[`$co_w-1`:0];
   //;}

endmodule

