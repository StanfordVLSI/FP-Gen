/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/ArrayColumn.vp#4 $
 ** $DateTime: 2011/10/06 15:10:49 $
 ** $Change: 9561 $
 ** $Author: sameh $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a ArrayColumn that process a vertical slice in multiplication tree 
 * using a linear array architecture
 *
 * Parameters:
 * * ColumnHight, ColumnPosition, MinRow, BoothType, OneLessCarryIn, LayoutShape
 * 
 *
 * Inputs:
 * * Given that N=ColumnHight
 * * [N-1:0] pp                 
 * * [(N-3)-1:0] ci   (Note: if OneLessCarryIn then we have one less ci)
 *  
 * Outputs:
 * * sum
 * * carry
 * * [(N-3)-1:0] co
 *
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; # use POSIX qw(floor ceil); # For floor and ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters

//; my $col_ht = parameter(Name=>'ColumnHight', Val=>2, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products in relevant column to sum");
//; my $col = parameter(Name=>'ColumnPosition', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The column number");
//; my $min_row = parameter(Name=>'MinRow', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The starting row position");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $one_less_ci = parameter(Name=>'OneLessCarryIn', Val=>0, Min=>0, Step=>1, Max=>1,
//;                      Doc=>"Is there one less carry in for this column?");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; my $ci_w = ($one_less_ci) ? $col_ht-4:$col_ht-3;
//; $ci_w = 0 if ($ci_w < 0); # can't have negative width
//; my $co_w = $col_ht-3;
//; $co_w = 0 if ($co_w < 0); # can't have negative width
//;
//; # print STDERR "DEBUG: hight=$col_ht, col=$col, min_row=$min_row, booth=$booth, ci_w=$ci_w, co_w=$co_w \n";

module `mname()` (
    input logic [`$col_ht-1`:0] pp,
//; if($ci_w){
    input logic  [`$ci_w-1`:0] ci,
//; }
//;if($co_w){
    output logic [`$co_w-1`:0] co,
//;}
    output logic sum, carry
   );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */

   logic [`$co_w`:0] inter_sum;
   logic [`$co_w`:0] inter_co;

   //; # local variables for index etc.
   //; my $row = $min_row;
   //; my $Y = $col;
   //; my $pp_idx = 0; my $sum_idx = 0;
   //; my $ci_idx = 0; my $co_idx = 0;

   //; ############## First Cell ##############
   // First CSA (fully populated with PPs)
   //; # Determine the physical location for the CSA/HA cell
   //; $Y = $col - $row * $booth if $layout_shape =~ /Square/;
   //; $Y = $col if $layout_shape =~ /Parallelogram/;
   //; if ($col_ht==2){
   //;   my $CSA_obj = generate('HA', "csa_${row}_${Y}");
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(pp[`$pp_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   //; } else {
   //;   my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // No inter_sum or carry_in to the first CSA so use all inputs for pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(pp[`$pp_idx++`]), .ci(pp[`$pp_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   //; }
   //; $row++;

   
   //; ############## Column Body ##############
   //; while ($pp_idx < $col_ht-1){
   //;   # Determine the physical location for the CSA/HA cell
   //;   $Y = $col - $row * $booth if $layout_shape =~ /Square/;
   //;   $Y = $col if $layout_shape =~ /Parallelogram/;
   //;   my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // Regular case: pp, inter_sum and ci
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(inter_sum[`$sum_idx++`]), .ci(ci[`$ci_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   
   //;   $row++;
   //; } # End of "while ($pp_idx < $col_ht-1){..."

   //; ############## FINAL CELL ##############
   //; # Determine the physical location for the CSA/HA cell
   //; if ($pp_idx < $col_ht){
   //;   $Y = $col - $row * $booth if $layout_shape =~ /Square/;
   //;   $Y = $col if $layout_shape =~ /Parallelogram/;
   //;   if ($one_less_ci){
   //;     my $CSA_obj = generate('HA', "csa_${row}_${Y}");
   // Just a half adder to add the last pp
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(inter_sum[`$sum_idx++`]),
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   //;   }else{
   //;     my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   // Final cell: Regular case: pp, inter_sum and ci
   `$CSA_obj->instantiate()` ( .a(pp[`$pp_idx++`]), .b(inter_sum[`$sum_idx++`]), .ci(ci[`$ci_idx++`]), 
			       .s(inter_sum[`$sum_idx`]), .co(inter_co[`$co_idx++`]) );
   //;   }
   //; } # End of "if ($pp_idx < $col_ht){..."
   

   //; $self->error("How come ci_idx($ci_idx)!=ci_w($ci_w) or pp_idx($pp_idx)!=col_ht($col_ht) ".
   //;		    "or sum_idx($sum_idx)!=inter_sum_w($co_w) or co_idx($co_idx)!=co_w+1($co_w+1)??") 
   //; 		   unless $ci_idx==$ci_w && $pp_idx==$col_ht && $sum_idx==$co_w && $co_idx==$co_w+1;
   
   assign sum = inter_sum[`$co_w`];
   assign carry = inter_co[`$co_w`];
   //;if($co_w){
   assign co = inter_co[`$co_w-1`:0];
   //;}

endmodule

