/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/Booth2Enc.vp#7 $
 ** $DateTime: 2011/11/11 21:07:01 $
 ** $Change: 9724 $
 ** $Author: shacham $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Booth TWO encoding for a multiplier.
 * 
 * Booth encoder produce the selet signals for partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 2 encoder
 * 
 * Y[2:0]     out  =  pp   +   S
 * 
 * 0 0 0      +0      100000  +0      
 * 0 0 1      +X      (10X)   +0
 * 0 1 0      +X      (10X)   +0
 * 0 1 1      +2X     (1X0)   +0
 * 1 0 0      -2X     (0~X1)  +1
 * 1 0 1      -X      (01~X)  +1
 * 1 1 0      -X      (01~X)  +1
 * 1 1 1      -0      011111  +1
 * 
 * NOTE: There is 1 to be augmented to the left of the partial products 
 *       excepf for the first one
 * 
 * 
 * 
 * Parameters:
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 05, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor and ceiling rounding math
//;
//; # module parameters
//; my $booth = parameter(Name=>'BoothType', Val=>2, Min=>2, Step=>1, Max=>8,
//;                       Doc=>"Booth type. Required parameter at instantiation.");
//; my $width = parameter(Name=>'Width', Val=>24, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");
//;
//; # Declare some local variables
//; my $extended_width = $width + 1 + $booth - ( $width % $booth);   # extended_width = width is odd?  width+2: width+3
//;
//; my $pp_count = ceil(($width + 1) / $booth);  # pp_count = width is odd? (width+1)/2 : (width+2)/2
//; my $sel_width = 2**($booth-1)+1;

module `mname` (
    input logic [`$width-1`:0]  x,
    input logic [`$extended_width-1`:0] extended_y,
      //;   if ($booth>=3) {
    output logic [`$width+1`:0] x3,
      //;   }
      //;   if ($booth>=4) {
    output logic [`$width+2`:0] x5, x7,
      //;   }
    output logic [`$pp_count*$sel_width-1`:0] sel_x
		);

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */

   //; if ($booth>=3) {
   //;   my $HM3_obj = generate('HardMultiple3', 'HM3', Width=>$width);
   `$HM3_obj->instantiate`  (.x(x), .x3(x3));
   //; }
   
   //; if ($booth>=4) {
   //;   my $HM5_obj = generate('HardMultiple5', 'HM5', Width=>$width);
   `$HM5_obj->instantiate` ( .x(x), .x5(x5));

   //;   my $HM7_obj = generate('HardMultiple7', 'HM7', Width=>$width);
   `$HM7_obj->instantiate` ( .x(x), .x7(x7));
   //; }

   //; for(my $i=0; $i < $pp_count; $i++){
   //;   my $BoothSel_obj = generate('BoothSel', "BoothEnc_u${i}_Booth_sel", BoothType=>$booth);
   `$BoothSel_obj->instantiate` ( .y ( extended_y[`($i+1)*$booth`:`$i*$booth`] ) ,
                                  .sel_x ( sel_x[`($i+1)*$sel_width-1`:`$i*$sel_width`] ) );
   //; }

endmodule

