/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/Booth2Enc.vp#7 $
 ** $DateTime: 2011/11/11 21:07:01 $
 ** $Change: 9724 $
 ** $Author: shacham $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Booth TWO encoding for a multiplier.
 * 
 * Booth encoder produce the selet signals for partial products for computing (x+xinc)*(y+yinc)
 * 
 * Modified Booth 2 encoder
 * 
 * Y[2:0]     out  =  pp   +   S
 * 
 * 0 0 0      +0      100000  +0      
 * 0 0 1      +X      (10X)   +0
 * 0 1 0      +X      (10X)   +0
 * 0 1 1      +2X     (1X0)   +0
 * 1 0 0      -2X     (0~X1)  +1
 * 1 0 1      -X      (01~X)  +1
 * 1 1 0      -X      (01~X)  +1
 * 1 1 1      -0      011111  +1
 * 
 * NOTE: There is 1 to be augmented to the left of the partial products 
 *       excepf for the first one
 * 
 * 
 * 
 * Parameters:
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 05, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor and ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $booth = parameter(Name=>'BoothType', Val=>2, Min=>2, Step=>1, Max=>8,
//;                       Doc=>"Booth type. Required parameter at instantiation.");
//; my $width = parameter(Name=>'Width', Val=>24, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");
//; my $encode_fanout = parameter(Name=>'EncFanout', Val=>18, Min=>1, Step=>1,
//;                       Doc=>"Fanout of Booth select signals");
//; $encode_fanout = ceil( ($width+$booth-1) / ceil( ($width+$booth-1) / $encode_fanout ) );

//$encode_fanout = `$encode_fanout`


module `mname` (
    input logic [`$width-1`:0]  x,
      //;   if ($booth>=3) {
    input logic [`$width+1`:0] 	x3,
      //;   }
      //;   if ($booth>=4) {
    input logic [`$width+2`:0] 	x5,x7,
      //;   }
    input logic	[`$booth`:0]	    y,          // y[`$booth-1`]
    output logic [`$width+$booth-1`:0]   pp,             // extend width by two: 1 bit for sign and ($booth-1) for shifting for 2^($booth-1) multiple
    output logic		    S
		);

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */
   
   logic [`$width+2*$booth-3`:0]     x_padded;
   assign x_padded = {`$booth-1`'b0, x, `$booth-1`'b0};

  //;   if ($booth==3){
   logic [`$width+1`:0] 	x3_padded;
   assign x3_padded = x3; // yep, I know it's not really padded, but it's for the naming convention later   
  //;   }elsif ($booth>=4) {
   logic [`$width+3`:0] 	x3_padded;
   assign x3_padded = {1'b0, x3, 1'b0};
  //;   }

  //;   if ($booth==2){
   assign S = y[2] & (~y[1]|~y[0]);
  //;   } else {
   assign S = y[`$booth`];
  //;   }

   //;if ($booth==2) {
   logic [`$width+2*$booth-3`:0] xn;
   assign xn[0] = ~y[2];
   //;}


   //;   my $j=-1;
   //;   for(my $i=$booth-1; $i < $width+2*($booth-1); $i++){ # need to iterate from 0 to (width+booth-1), but shift by booth-1
   //;     if (($i-$booth+1)%$encode_fanout==0){
   //;       $j++;
   //;       my $BoothSel_obj = generate('BoothSel', "Booth_sel_${j}", BoothType=>$booth);
   logic  [`(2**($booth-1))-1`:0] sel_x`$j`;
   `$BoothSel_obj->instantiate` ( .y(y), .sel_x(sel_x`$j`));      

   //;     }
   //;     my $BoothCell_obj = generate('BoothCell', "cell_$i", BoothType=>$booth);
   `$BoothCell_obj->instantiate` 
     (.sel_x(sel_x`$j`),

      .x( {
   //;     if ($booth>=4) {
           x_padded[`$i-3`], x7[`$i-3`], x3_padded[`$i-3`] , x5[`$i-3`],
   //;     }
   //;     if ($booth>=3) {
           x_padded[`$i-2`], x3_padded[`$i-2`],
   //;     }
           x_padded[`$i-1`] , x_padded[`$i`] } ),
   //;if ($booth==2) {
           .xn1(xn[`$i-1`]), .xn0(xn[`$i`]),
   //;}
      .y(y) , .pp(pp[`$i-$booth+1`]));
   
   //;   }

   assign pp[`$width+$booth-1`] = ~S;
endmodule

