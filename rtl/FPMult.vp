/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * A floating point multiplier that takes two floating point number A, B and 
 * produces the result AxB in full precision without any truncation. 
 * The output may be used for constructing a cascade FMA or rounded to 
 * input precision to construct a FP multiplier
 * 
 * 
 * Parameters:
 * * FractionWidth, ExponentWidth, EnableDenormals, EnableForwarding
 * * PipelineDepth, EnableMultiplePumping, MulpPipelineDepth, FloatingDigits
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Oct 01, 2011   shacham   init version - ported Sameh's original code to 
 *                         genesis
 * Apr 21, 2011  tema8     added multi precision
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil floor log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters

//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52,  Min=>4, Step=>1, 
//;                           Doc=>"Width of the Fraction for the multiplier (default is IEEE Double, 52 bit)");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, Min=>4, Step=>1, 
//;                           Doc=>"Width of the exponent for the multiplier (default is IEEE Double, 11 bit)");
//; my $enable_denormals = parameter(Name=>'EnableDenormals', Val=>'YES',  List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO) FUNCTIONAL!");
//;
//; my $enable_forwarding = parameter(Name=>'EnableForwarding', Val=>'YES', List=>['YES', 'NO'],
//; 			   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc)");
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>4, List=>[ 0,1,2,3,4,5,6,7 ] ,
//;                       Doc=>"Pipeline depth");
//; my $enableMultiplePumping = parameter(Name=>'EnableMultiplePumping', Val=>'NO', List=>['YES', 'NO'],
//; 			  Doc=>"!FUNCTIONAL! Use parallel MultiplierP unit");

//; # Multi precision mode
//; my $useMP = parameter(Name=>'UseMP', Val=>0, List=>[1, 0],
//; 			  Doc=>"Multi precision mode: Treat inputs as 2 numbers and produce 2 results.");
//; my $floating_digits= parameter(Name=>'FloatingDigits', Val=>1,  List=>[1,2],
//; 			   Doc=>"Number of digits before floating point");
//; my $mulp_pipeline_depth = parameter(Name=>'MulpPipelineDepth', Val=>floor($pipeline_depth/2),
//;                       Doc=>"!FUNCTIONAL! MultiplierP Part Pipeline depth");
//; my $add_pipeline_depth = $pipeline_depth - $mulp_pipeline_depth;
//;
//; # And some local variables
//; my $shift_width = CeilOfLog2($frac_width+1) + 1;
//; my $product_width = 2 * $frac_width + 2;

module `mname`(
   //; if ($verif_mode =~ /ON/){
    input logic dumptolog,
   //; }
   //; if ($useMP){
    input logic                   mp_mode,
   //; }
    input logic [`$exp_width + $frac_width`:0] 	a_in, b_in,
   //; if ($enable_forwarding =~ /YES/){
    input logic forward_a, forward_b,	
    input logic [`$exp_width + $frac_width`:0] z_preInc, z_postInc,
    input logic IncZ,
   //; }
   //; if ($pipeline_depth>0) {
    input logic  clk , reset, valid_in, stall_in, adder_mode, multiplier_mode,	       
    output logic valid_out, stall_request,
   //; }
    output logic 			      SignAB_out, NANAB_out, InfAB_out, ZeroAB_out,
    output logic [`$exp_width + 1`:0] 	      ExpAB_out,
    output logic [`$product_width - 1`: 0]    ManAB_out
	       );

   logic 			      SignAB, NANAB, InfAB, ZeroAB;
   logic [`$exp_width + 1`:0] 	      ExpAB;
   logic [`$product_width - 1`: 0]    ManAB;

   logic [`$exp_width + $frac_width`:0] a,b, a0, a1, A_adder_mode, A_pl, B_pl;
   logic ainc, binc, IncA_pl, IncB_pl, mp_mode_pl, adder_mode_pl, forward_a0, forward_a_pl, valid_A0, valid_A, valid_mul, valid_ManAB, valid_middle, stall;   
   logic [`$frac_width - 1`:0] 		      SigA, SigB;
   logic [`$frac_width`:0] 		      ManA, ManA1, manA_adder_mode, ManB;
   logic [`$exp_width - 1`:0] 		      ExpA, ExpA_adder_mode, ExpB;
   logic [`$exp_width + 1`:0] 		      bias_offset, Eab_ps0, Eab_ps1, ExpAB0, ExpAB1;
   logic [`$product_width-1`: 0] 	      ManAB_unnormalized, ManAB_shifted, ManAB_normalized;
   //if IncA=IncB=1, ManA=ManB=`$frac_width`'b1, the product may be 1 bit larger
   logic [`$product_width`: 0] 		      ManAB_unnormalized_long;
   logic 				      NANorInfA, NANorInfB, zeroSigA, zeroSigB, InfA;
   logic 				      InfB, NANA, NANB, SignA, SignB, ZeroExpA, ZeroExpB, ZeroExpA_prePipeline, ZeroExpB_prePipeline;
   logic 				      ZeroA, ZeroB, co_dummy0, co_dummy1, co_dummy2;
   logic 				      co_dummy3, co_dummy4, shiftleft;

   //; if ( ! $useMP){
   logic mp_mode;
   assign mp_mode = 0;
   //; }



//; if($enable_forwarding =~ /YES/ && $pipeline_depth > 0 ){
   assign {a,ainc} = forward_a? {z_preInc,IncZ}:{a_in,1'b0};
   assign {b,binc} = forward_b? {z_preInc,IncZ}:{b_in,1'b0};
   assign a1 = forward_a0? z_postInc : a0;
//; } else {
   logic forward_a = 0;
   assign {a,b,ainc,binc} = {a_in,b_in,2'b0};
   assign a1 = A_pl;
//; }



   assign ZeroExpA_prePipeline  =  ~|a[`$exp_width + $frac_width - 1`:`$frac_width`];
   assign ZeroExpB_prePipeline  =  ~|b[`$exp_width + $frac_width - 1`:`$frac_width`];

//; if ($pipeline_depth > 0 ) {
//;   my $pipein = generate(  'Pinned_pipeline',  'pipein',  Width=> 2*$exp_width + 2*$frac_width + 8 , PipelineDepth => $pipeline_depth);
  `$pipein ->instantiate()` ( .in ({a,b,ainc,binc,mp_mode, ZeroExpA_prePipeline, ZeroExpB_prePipeline, adder_mode}) ,
                              .valid_in(valid_in), .clk(clk) , .stall(stall), .reset(reset),
                              .out({A_pl,B_pl,IncA_pl,IncB_pl,mp_mode_pl, ZeroExpA, ZeroExpB, adder_mode_pl}),
                              .valid_out(valid_out) );


//;   my $pipeA0 = generate(  'Pinned_pipeline',  'pipe_A0',  Width=> $exp_width + $frac_width + 2 , PipelineDepth => 1);
  `$pipeA0 ->instantiate()` ( .in ({a,forward_a}) , .out({a0,forward_a0}),
                              .valid_in(valid_in & adder_mode), .clk(clk) , .stall(stall), .reset(reset),
                              .valid_out(valid_A0) );

	
//; my $pipeA1 = generate(  'FF_pipeline',  'pipe_A1',  Width=> $exp_width + $frac_width + 1 , PipelineDepth => $pipeline_depth-1, Retime=>'YES');
  `$pipeA1 ->instantiate()` ( .in(a1) , .out(A_adder_mode),
                              .valid_in(valid_A0), .clk(clk) , .stall(stall), .reset(reset), 
                              .valid_out(valid_A) );
//; } else  {
  assign {A_pl,B_pl,IncA_pl,IncB_pl,mp_mode_pl, ZeroExpA, ZeroExpB } = {a,b,ainc,binc,mp_mode, ZeroExpA_prePipeline, ZeroExpB_prePipeline};
  assign adder_mode_pl = 0;
  assign A_adder_mode = a;
 
//; }


   assign SignA = A_pl[ `$exp_width + $frac_width` ];
   assign SignB = B_pl[ `$exp_width + $frac_width` ];
   assign ExpA  = A_pl[`$exp_width + $frac_width - 1` : `$frac_width` ] ;
   assign ExpB  = B_pl[`$exp_width + $frac_width - 1` : `$frac_width` ] ;
   assign SigA  = A_pl[`$frac_width - 1` : 0 ];
   assign SigB  = B_pl[`$frac_width - 1` : 0 ];

   assign zeroSigA = SigA=={(`$frac_width`){IncA_pl}};
   assign zeroSigB = SigB=={(`$frac_width`){IncB_pl}};

   assign ZeroA = zeroSigA & ZeroExpA & ~IncA_pl;
   assign ZeroB = zeroSigB & ZeroExpB & ~IncB_pl;

   assign ManA = { ~ZeroExpA , SigA };
   assign ManB = { ~ZeroExpB , SigB };

   assign NANorInfA = ( & ExpA[`$exp_width - 1` : 1])  & ( ExpA[0] | (IncA_pl & zeroSigA) )  ;
   assign NANorInfB = ( & ExpB[`$exp_width - 1` : 1])  & ( ExpB[0] | (IncB_pl & zeroSigB) )  ;

   assign InfA      =  zeroSigA & NANorInfA;
   assign InfB      =  zeroSigB & NANorInfB;

   assign NANA      = ~zeroSigA & NANorInfA;
   assign NANB      = ~zeroSigB & NANorInfB;
   
   assign NANAB = NANA | NANB | (InfA & ZeroB) | (InfB & ZeroA);
   assign InfAB = (InfB | InfA) & ~NANAB ;

   assign ZeroAB = ZeroA | ZeroB;
   assign SignAB = SignA ^ SignB;


// bypass the flopped versions of A and B because the unit is pipelined internally
//; my $Mul_obj = generate('Multiplier', 'Mult', Width=>$frac_width+1, UseInc=>$enable_forwarding, 
//;                        MulpPipelineDepth=> $mulp_pipeline_depth, EnableMultiplePumping=> $enableMultiplePumping, 
//;                        AddPipelineDepth=> $add_pipeline_depth , UseMP=>($useMP)?"YES":"NO");
  `$Mul_obj->instantiate()` 
     (
      //; if ($verif_mode =~ /ON/){
       .dumptolog(dumptolog),
      //; }
      .a( { ~ZeroExpA_prePipeline, a[`$frac_width - 1` : 0 ] } ),
      .b( { ~ZeroExpB_prePipeline, b[`$frac_width - 1` : 0 ] } ), 
	       
      //; if ($useMP){
      .mp_mode(mp_mode),
      //; }
      //; if($enable_forwarding =~ /YES/){
      .ainc(ainc), .binc(binc),
      //; }
      //; if ($pipeline_depth>0) {
      .valid_in(valid_in & !adder_mode),
      .stall(stall), .clk(clk) , .reset(reset),
      .valid_out(valid_mul),
      //; }
      .out(ManAB_unnormalized_long)
      );
  
  assign shiftleft = zeroSigA & IncA_pl & zeroSigB & IncB_pl ;

  assign ManAB_unnormalized = shiftleft?
                                     ManAB_unnormalized_long[`$product_width`:1] 
                                   : ManAB_unnormalized_long[`$product_width-1`:0];

//; if ($enable_denormals=~ /YES/){
   // enable_denormals = YES
    logic [`$exp_width + 1`:0] Eab_ps2, Eab_ps3, Eab_ps4, Eab_ps5;
    logic [`$shift_width - 1`:0] LZD_A, LZD_B;
    logic [`$frac_width`:0]  dec_a, dec_b;
    logic [`$shift_width`:0] shiftAmount;


    // Eab = Ea + Eb - BIAS - LZD_A - LZD_B + ZeroExpA + ZeroExpB
    //     = Ea + Eb + bias_offset + ~LZD_A + ~LZD_B + ZeroExpA + ZeroExpB (where bias_offset = -BIAS +2)

    assign bias_offset = - {(`$exp_width-1`){1'b1}} + 2; // sign extend the bias to be exp_width+2=`$exp_width`+2 wide

    DW_lzd #(`$frac_width`+1) LZDA ( .a({ManA[`$frac_width`:1],ManA[0]|IncA_pl}), .enc(LZD_A) , .dec(dec_a));
    DW_lzd #(`$frac_width`+1) LZDB ( .a({ManB[`$frac_width`:1],ManB[0]|IncB_pl}), .enc(LZD_B) , .dec(dec_b));
    assign shiftAmount = LZD_A + LZD_B;



    DW01_csa #(`$exp_width`+2) EAB_CSA1  (.a(Eab_ps0),.b(Eab_ps1),
					  .c({{(`$exp_width+2-$shift_width`){1'b1}},~LZD_A}),
					  .ci(ZeroExpA), .carry(Eab_ps2), .sum(Eab_ps3), 
					  .co(co_dummy1) );
    DW01_csa #(`$exp_width`+2) EAB_CSA2  (.a(Eab_ps2),.b(Eab_ps3),
					  .c({{(`$exp_width+2-$shift_width`){1'b1}},~LZD_B}),
					  .ci(ZeroExpB), .carry(Eab_ps4), .sum(Eab_ps5), 
					  .co(co_dummy2) );
   
   //; my $ExpAdd_obj = generate('CompoundAdder', 'ExpAdd', Width=>($exp_width+2), EnableCarryIn=>'OFF', ZeroWidth=>0);   
   `$ExpAdd_obj->instantiate()` 
     (
      //; if ($verif_mode =~ /ON/){
      .dumptolog(dumptolog),
      //; }
      .a(Eab_ps4), .b(Eab_ps5), .sum0(ExpAB0), .co0(co_dummy3),  .sum1(ExpAB1), .co1(co_dummy4));

//; if( $pipeline_depth > 0 ){
    logic [`$product_width-1`: 0] ManAB_unnormalized_m;
    logic [`$shift_width`:0] shiftAmount_m;
    logic normalize_ManAB;
    reg stalled;

    assign normalize_ManAB = ~adder_mode_pl & (ZeroExpA | ZeroExpB) & ~ZeroAB;
    assign stall_request = stalled? 0: normalize_ManAB ;
    assign stall = stall_request | stall_in;
    
    always @(posedge clk)
    if (reset)
      stalled <= 0;
    else
      stalled <= stall;

//;   my $normalization_pipe = generate('Pinned_pipeline','norm_stage', Width=> $product_width+$shift_width+1, PipelineDepth=> 1);
    `$normalization_pipe ->instantiate()` (
       .in({ManAB_unnormalized,shiftAmount}) , .valid_in(stall_request), .clk(clk) , .stall(1'b0), .reset(reset), 
       .out( {ManAB_unnormalized_m,shiftAmount_m}), .valid_out(valid_ManAB) );

    assign ManAB_shifted = ManAB_unnormalized_m << shiftAmount_m; 
    assign ManAB_normalized = normalize_ManAB ? ManAB_shifted : ManAB_unnormalized;
//; } else {
    assign ManAB_normalized = ManAB_unnormalized << shiftAmount;
//; }
    

//; }else{ 
          
   // enable_denormals = NO

   assign bias_offset = - {(`$exp_width-1`){1'b1}}; // sign extend the bias to be exp_width+2=`$exp_width`+2 wide

   //; my $ExpAdd_obj = generate('CompoundAdder', 'ExpAdd', Width=>($exp_width+2), EnableCarryIn=>'OFF', ZeroWidth=>0);   
   `$ExpAdd_obj->instantiate()` 
     (
      //; if ($verif_mode =~ /ON/){
      .dumptolog(dumptolog),
      //; }
      .a(Eab_ps0), .b(Eab_ps1), .sum0(ExpAB0), .co0(co_dummy3),  .sum1(ExpAB1), .co1(co_dummy4)
      );

    assign ManAB_normalized = ManAB_unnormalized;
    assign stall = stall_in;
    assign stall_request = 0;
//; }

  DW01_csa #(`$exp_width+2`) EAB_CSA0  (.a({2'b00, ExpA}),.b({2'b00, ExpB}),.c(bias_offset),
					.ci(shiftleft), .carry(Eab_ps0), .sum(Eab_ps1), .co(co_dummy0) );

//;  if ($floating_digits==1) {
  assign ExpAB = ZeroAB? 0 : ( ManAB_normalized[`$product_width-1`]? ExpAB1 : ExpAB0);
  assign ManAB = ManAB_normalized[`$product_width-1`]? ManAB_normalized : {ManAB_normalized[`$product_width-2`:0],1'b0};
//; } else {
  assign ExpAB = ZeroAB? 0 : ExpAB0;
  assign ManAB = ManAB_normalized;
//; }


   assign ExpA_adder_mode = A_adder_mode[`$exp_width + $frac_width - 1`:`$frac_width`];
   assign manA_adder_mode = { ~|ExpA_adder_mode, A_adder_mode[`$frac_width - 1` : 0 ] };
   
   assign {InfAB_out,NANAB_out, ZeroAB_out, SignAB_out} = adder_mode_pl? 
                                                     {InfA,NANA, ZeroA, SignA}
                                                   : {InfAB, NANAB, ZeroAB, SignAB};

   assign {ExpAB_out, ManAB_out} = adder_mode_pl? 
                                                     {2'b0,ExpA_adder_mode, 1'b0, manA_adder_mode, `$frac_width`'b0}
                                                   : {ExpAB, ManAB};


//; if ($verif_mode =~ /ON/){
// synopsys translate_off
   always @(posedge dumptolog)
     begin
	$display ("`$self->get_instance_path()`: ZeroExpA=0x%h ZeroA=0x%h InfA=0x%h ExpA=%h ManA=%h, SigA=%h IncA=0x%h",ZeroExpA, ZeroA, InfA, ExpA, ManA, SigA, IncA_pl);
	$display ("`$self->get_instance_path()`: ZeroExpB=0x%h ZeroB=0x%h InfB=0x%h ExpB=%h ManB=%h, SigB=%h IncB=0x%h",ZeroExpB, ZeroB, InfB, ExpB, ManB, SigB, IncB_pl);
	$display ("`$self->get_instance_path()`: ExpAB=%h , ManAB=%h, SignAB=%h, NANAB=%h, InfAB=%h, ZeroAB=%h",ExpAB, ManAB, SignAB, NANAB, InfAB, ZeroAB);
	$display ("`$self->get_instance_path()`: ExpAB0=%h, ExpAB1=%h",ExpAB0, ExpAB1);
	$display ("`$self->get_instance_path()`: ManAB_unnormalized =%h ManAB_normalized =%h ManAB_unnormalized_long =%h", ManAB_unnormalized,ManAB_normalized,ManAB_unnormalized_long);
    //;if ($enable_denormals=~ /YES/){
	$display ("`$self->get_instance_path()`: ManAB_shifted=%h shiftAmount=%h", ManAB_shifted, shiftAmount);
    //;}
     end
// synopsys translate_on
 //; }

endmodule : `mname`
