
/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/FMA.vp#1 $
 ** $DateTime: 2011/12/24 22:02:13 $
 ** $Change: 9979 $
 ** $Author: sameh06 $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * FMA datapath
 * Status flag bits
 * ______________________________
 * Bit| Flag      | Description
 * ______________________________
 *  0 | Zero      | Integer or floating point output is zero.
 *  1 | Infinity  | Floating point output is infinity.
 *  2 | Invalid   | Floating point operation is not valid (0x∞, ∞-∞ ) . It is also set to 1 when one of the inputs is NaN
 *  3 | Tiny      | Non zero floating point output after rounding has a magnitude less than the minimum normalized number( a denormalized number)
 *  4 | Huge      | Finite floating point result after rounding has a magnitude greater than the maximum normalized number.
 *  5 | Inexact   | Integer or floating point output is not equal to the infinitely precise result.
 * ______________________________
 *  
 * 
 * Parameters:
 * ------------
 * * FractionWidth, ExponentWidth, EnableDenormals, useInc
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Jan 24, 2012   sameh06   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off. !IGNORE!" ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.  !IGNORE!");
//; my $desinware_mode = parameter(Name=>'Designware_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Designware mode determines whether or not ".
//;                                 "designware codes are used instead of our ".
//;                                 "design.  !IMPLEMENTATION!");

//;
//; # module parameters
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the Fraction for the multiplier (default is IEEE Double, 52 bit) !FUNCTIONAL!");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the exponent for the multiplier (default is IEEE Double, 11 bit) !FUNCTIONAL!");
//; my $enable_denormals = parameter(Name=>'EnableDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO) !FUNCTIONAL!");
//;
//; my $useInc ;
//; if( $desinware_mode eq 'OFF' ){
//;     $useInc = parameter(Name=>'UseInc', Val=>'YES', List=>['YES', 'NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; } elsif($desinware_mode eq 'ON'){
//;     $useInc = parameter(Name=>'UseInc', Val=>'NO', List=>['NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; }
//;
//; # And some local variables
//; # $useInc = ($useInc =~ /YES/)? 1:0;
//; my $product_width = 2 * $frac_width + 2;
//; my $wide_width = 4 * $frac_width  + 7; # 1 sign bit + (frac_width+1) + 2 guard bits + (2*frac_width+2) + (frac_width+1)
//; my $shift_width = CeilOfLog2($wide_width);
//; my $lza_width = $wide_width - $frac_width - 1;
//; my $lza_enc_width = CeilOfLog2($lza_width) + 1;
//;


module `mname` (
   //; if ($verif_mode =~ /ON/){
    input  logic dumptolog,
   //; }
    input  logic [`$exp_width + $frac_width`:0] a, b, c,
    input  logic ainc, binc, cinc,
    input  logic [2:0] rnd,

    input logic clk ,
    input logic rst ,
		
    output logic [`$exp_width + $frac_width`:0] z,
    output logic zinc,
    output logic [7:0] status
           );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */
//; if( $desinware_mode eq 'ON' ){

   DW_fp_mac #( `$frac_width` , `$exp_width` , `$enable_denormals eq 'YES' ?1:0` ) U1 (
									       .a(a),
									       .b(b),
									       .c(c),
									       .rnd(rnd),
									       .z(z),
									       .status(status) );
   
   
//; } elsif( $desinware_mode eq 'OFF'  ) {
  wire [`$frac_width`:0] ManResult;
  wire [`$frac_width-1`:0] SigA, SigB, SigC;
  wire [`$frac_width`:0] ManA, ManB, ManC;
  wire [`$shift_width-1`:0] RshiftAmt;
  wire [`$lza_enc_width-1`:0] LshiftAmt;
  wire [`$lza_width-1`:0] lza_override_mask;
  wire [`$exp_width-1`:0] ExpA, ExpB, ExpC, ExpResult;
  wire [`$exp_width + $frac_width`:0] FMA_Result;
  wire SignA, SignB, SignC;
  wire ManLSB, Guard, Sticky, IncExp,IncExpFromLZA, LZA_wrong, RoundInc, SignResult,SignInfinity;

  wire denormA, denormB, denormC, denormResult, NANorInfA, NANorInfB, NANorInfC, zeroSigA, zeroSigB, zeroSigC, zeroManResult, IncCarryOut;
  wire InfA, InfB, InfC, InfFromInput, NANA, NANB, NANC, ZeroA, ZeroB, ZeroC, ZeroResult;
  wire SignProduct, SignSpecial, ResultIsInfinity, ResultIsC, ResultIsFMA, ResultExactZero;
  wire FV_exp, FU_exp;
  wire FX, FV, FU, FI, Tiny;
  wire RndMaxNum, MaxNum;
      logic 				      zeroSigAplusInc, zeroSigBplusInc, zeroAplusInc, zeroBplusInc, InfAplusInc, InfBplusInc, NANAplusInc, NANBplusInc, NANorInfAplusInc, NANorInfBplusInc, MaxA, MaxB;

  assign SignA = a[`$exp_width + $frac_width`];
  assign SignB = b[`$exp_width + $frac_width`];
  assign SignC = c[`$exp_width + $frac_width`];

  assign ExpA = a[`$exp_width + $frac_width -1`:`$frac_width`];
  assign ExpB = b[`$exp_width + $frac_width -1`:`$frac_width`];
  assign ExpC = c[`$exp_width + $frac_width -1`:`$frac_width`];

  assign denormA = ExpA == 0;
  assign denormB = ExpB == 0;
  assign denormC = ExpC == 0;

  assign SigA = a[`$frac_width -1`:0];
  assign SigB = b[`$frac_width -1`:0];
  assign SigC = c[`$frac_width -1`:0];

//assign Tiny = denormResult & ~ZeroResult;
  assign Tiny = 0;
  assign status = {2'b0, FX, FV, Tiny, FI, ResultIsInfinity, ZeroResult};

  assign zeroSigA = SigA==0;
  assign zeroSigB = SigB==0;
  assign zeroSigC = SigC==0;
  assign zeroManResult = ManResult==0;

  assign NANorInfA =  ExpA == {(`$exp_width`){1'b1}};
  assign NANorInfB =  ExpB == {(`$exp_width`){1'b1}};
  assign NANorInfC =  ExpC == {(`$exp_width`){1'b1}};

  assign InfA = zeroSigA & NANorInfA;
  assign InfB = zeroSigB & NANorInfB;
  assign InfC = zeroSigC & NANorInfC;
  

  assign NANA = ~zeroSigA & NANorInfA;
  assign NANB = ~zeroSigB & NANorInfB;
  assign NANC = ~zeroSigC & NANorInfC;


   assign MaxA      =  ExpA=={{(`$exp_width-1`){1'b1}},1'b0} && SigA=={(`$frac_width`){1'b1}};
   assign MaxB      =  ExpB=={{(`$exp_width-1`){1'b1}},1'b0} && SigB=={(`$frac_width`){1'b1}};
   
   assign NANorInfAplusInc = NANorInfA | (ainc & MaxA);
   assign NANorInfBplusInc = NANorInfB | (binc & MaxB);
   assign zeroSigAplusInc = (zeroSigA & ~(ainc & ~InfA & ~NANA)) | (ainc & MaxA);
   assign zeroSigBplusInc = (zeroSigB & ~(binc & ~InfB & ~NANB)) | (binc & MaxB);
   assign ZeroAplusInc = zeroSigAplusInc & denormA;
   assign ZeroBplusInc = zeroSigBplusInc & denormB;
   assign InfAplusInc =  zeroSigAplusInc & NANorInfAplusInc;
   assign InfBplusInc =  zeroSigBplusInc & NANorInfBplusInc;
   assign NANAplusInc = ~zeroSigAplusInc & NANorInfAplusInc;
   assign NANBplusInc = ~zeroSigBplusInc & NANorInfBplusInc;

  assign InfFromInput = InfAplusInc | InfBplusInc | InfC;
   
  assign ManA = { ~denormA , SigA};
  assign ManB = { ~denormB , SigB};
  assign ManC = { ~denormC , SigC};
  assign ZeroA = zeroSigA & denormA;
  assign ZeroB = zeroSigB & denormB;
  assign ZeroC = zeroSigC & denormC;

  assign ZeroResult = zeroManResult & denormResult;

  assign SignProduct = SignA ^ SignB;
  assign SignInfinity = InfC ? SignC : SignProduct;
  assign SignSpecial = SignC & (~ZeroC | SignProduct);

//; my $fma_exp_obj = generate('FMA_Exp', 'FMA_EXP0', FractionWidth=>$frac_width 
//;                                                 , ExponentWidth=>$exp_width
//;                                                 , EnableDenormals=>$enable_denormals
//;                                                 , UseInc => $useInc);
  `$fma_exp_obj->instantiate()` (
				 .ExpA(ExpA),
				 .ExpB(ExpB),
				 .ExpC(ExpC),
				 .denormA(denormA),
				 .denormB(denormB),
				 .denormC(denormC),
				 .ZeroC(ZeroC),
				 .RshiftAmt(RshiftAmt),
				 .lza_override_mask(lza_override_mask),
				 .LshiftAmt(LshiftAmt),
				 .IncExp(IncExp),
				 .denormResult(denormResult),
				 .ResultExactZero(ResultExactZero),
				 .ExpResult(ExpResult),
				 .FV(FV_exp)
				 //; if ($verif_mode =~ /ON/){
				  , .dumptolog(dumptolog)
				 //; }
				 );

//; my $fma_man_obj = generate('FMA_Man', 'FMA_MAN0', FractionWidth=>$frac_width 
//;                                                 , ExponentWidth=>$exp_width
//;                                                 , EnableDenormals=>$enable_denormals
//;                                                 , UseInc => $useInc);
  `$fma_man_obj->instantiate()`  (  .ManA(ManA), 
				    .ManB(ManB), 
				    //; if ($useInc eq 'YES'){
				    .IncA(ainc),		     
				    .IncB(binc),
				    //; }
			      	    .ManC(ManC), 
				    .SignA(SignA), 
				    .SignB(SignB), 
				    .SignC(SignC), 
				    .RshiftAmt(RshiftAmt), 
				    .lza_override_mask(lza_override_mask), 
				    .LshiftAmt(LshiftAmt), 
				    .Result(ManResult), 
				    .SignResult(SignResult), 
				    .ResultExactZero(ResultExactZero), 
				    .LSB(ManLSB), 
				    .Guard(Guard), 
				    .Sticky(Sticky), 
				    .IncExp(IncExp)
				    //; if ($verif_mode =~ /ON/){
				    , .dumptolog(dumptolog)
				    //; }
				    );

//; my $rnd_obj = generate('Rndlogic', 'Rndlgc');
  `$rnd_obj->instantiate()` (.rnd(rnd), .Sign(SignResult), .LSB(ManLSB), .Guard(Guard), .Sticky(Sticky), .Inc(RoundInc), .MaxNum(RndMaxNum));
  assign denormResult = ~ManResult[`$frac_width`];
  assign FMA_Result = {SignResult, ExpResult, ManResult[`$frac_width -1`:0]};		   
  


  assign FX = (ResultIsFMA & (Guard | Sticky)) | FV;
  assign FI = NANAplusInc | NANBplusInc | NANC | ((InfAplusInc | InfBplusInc) & InfC & (SignProduct!=SignC)) | (InfAplusInc & ZeroBplusInc) | (InfBplusInc & ZeroAplusInc);
  assign FV = FV_exp & ~InfFromInput & ~FI & ~ResultIsC ;
  assign FU = ZeroResult & FX & ResultIsFMA;


  assign ResultIsInfinity = ( InfFromInput | FV) & ~FI;
  assign ResultIsC = (ZeroAplusInc | ZeroBplusInc) & ~InfFromInput   & ~FI;
  assign ResultIsFMA = ~ResultIsC   & ~ResultIsInfinity   & ~FI;

  assign MaxNum =  FV & RndMaxNum; 

  assign {zinc,z} = FI ? {2'b0,{(`$exp_width+1`){1'b1}},{(`$frac_width -1`){1'b0}}}
              : ResultIsInfinity ? {1'b0,SignInfinity,{{(`$exp_width-1`){1'b1}}, ~MaxNum}, {(`$frac_width`){MaxNum}}}
                                    : ResultIsC ? {1'b0,SignSpecial,ExpC, ManC[`$frac_width -1`:0]} : {RoundInc, FMA_Result};
//; if ($verif_mode =~ /ON/){
  // synopsys translate_off
  always @(posedge dumptolog)
  begin
    $display ("denormA=%b ZeroA=%b InfA=%b ManA=%h",denormA, ZeroA, InfA, ManA);
    $display ("denormB=%b ZeroB=%b InfB=%b ManB=%h",denormB, ZeroB, InfB, ManB);
    $display ("denormC=%b ZeroC=%b InfC=%b ManC=%h",denormC, ZeroC, InfC, ManC);
    $display ("IncZ=%b SignZ=%b ExpZ=%h SigZ=%h",zinc,z[`$exp_width + $frac_width`],z[`$exp_width + $frac_width -1`:`$frac_width`],z[`$frac_width -1`:0]);
    $display ("ResultIsInfinity =%b , ResultIsC =%b ,ResultIsFMA =%b",ResultIsInfinity, ResultIsC,ResultIsFMA);
    $display ("FU =%b , FV =%b ,FI =%b ,FX =%b",FU, FV , FI,FX);
    $display ("ZeroResult=%b ,zeroManResult=%b ,denormResult=%b", ZeroResult,zeroManResult,denormResult);
  end
  // synopsys translate_on
//; }
//; } #End Not Designware Loop
endmodule


