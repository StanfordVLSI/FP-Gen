
/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/FMA.vp#1 $
 ** $DateTime: 2011/12/24 22:02:13 $
 ** $Change: 9979 $
 ** $Author: sameh06 $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * FMA datapath
 * Status flag bits
 * ______________________________
 * Bit| Flag      | Description
 * ______________________________
 *  0 | Zero      | Integer or floating point output is zero.
 *  1 | Infinity  | Floating point output is infinity.
 *  2 | Invalid   | Floating point operation is not valid (0x∞, ∞-∞ ) . It is also set to 1 when one of the inputs is NaN
 *  3 | Tiny      | Non zero floating point output after rounding has a magnitude less than the minimum normalized number( a denormalized number)
 *  4 | Huge      | Finite floating point result after rounding has a magnitude greater than the maximum normalized number.
 *  5 | Inexact   | Integer or floating point output is not equal to the infinitely precise result.
 * ______________________________
 *  
 *
 * 
 *  Retiming Diagram 
 *
 *   Pin-In --->  [ pipeIn ] --> [pipeRetime0] --> [pipeRetime1] .... --> [pipeRetimeN] --> (FMA Design) ---> Pin-Out
 *                    |                 |             |           |           |                            
 *   clk -------------------------------------------------------------------------------------------------
 * 
 *   NOTES:
 *     pipeIn and and pipeOut are fixed and will not be retimed. 
 *     pipeRetime is not fixed and will be retimed.
 * 
 * Parameters:
 * ------------
 * * FractionWidth, ExponentWidth, EnableDenormals, PipelineDepth, EnableForwarding
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Jan 24, 2012   sameh06   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil floor log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off. !IGNORE!" ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.  !IGNORE!");
//; my $desinware_mode = parameter(Name=>'Designware_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Designware mode determines whether or not ".
//;                                 "designware codes are used instead of our ".
//;                                 "design.  !IMPLEMENTATION!");

//;
//; # module parameters
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the Fraction for the multiplier (default is IEEE Double, 52 bit) !FUNCTIONAL!");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the exponent for the multiplier (default is IEEE Double, 11 bit) !FUNCTIONAL!");
//; my $enable_denormals = parameter(Name=>'EnableDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO) !FUNCTIONAL!");
//; my $enable_forwarding ;
//; if( $desinware_mode eq 'OFF' ){
//;     $enable_forwarding = parameter(Name=>'EnableForwarding', Val=>'YES', List=>['YES', 'NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; } elsif($desinware_mode eq 'ON'){
//;     $enable_forwarding  = parameter(Name=>'EnableForwarding', Val=>'NO', List=>['NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; }
//;
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>7, Min=> (($enable_forwarding =~ /YES/)?3:0) ,
//;                       Doc=>"Pipeline depth !FUNCTIONAL!");
//; my $mulp_pipeline_depth = parameter(Name=>'MulpPipelineDepth', Val=>floor(3*$pipeline_depth/7), Min=>0, 
//;                       Max=> (($enable_forwarding =~ /YES/)?$pipeline_depth-1:$pipeline_depth) ,
//;                       Doc=>"Pipeline depth of the multiplier tree !FUNCTIONAL!");
//; my $enableMultiplePumping = parameter(Name=>'EnableMultiplePumping', Val=>'YES', List=>['YES', 'NO'],
//; 			  Doc=>"Use parallel MultiplierP unit !FUNCTIONAL!");
//; my $retiming ;
//; if( $pipeline_depth > 1 ){
//;   $retiming = parameter(Name=>'Retiming', Val=>1, List=>[ 0, 1 ] , 
//;                       Doc=>"Should retiming be run in synthesis !IMPLEMENTATION!");
//;   $retiming or $self->error( "Error: HACK-> Parameter may only be 1\n" ) ;
//; } else {
//;   $retiming = parameter(Name=>'Retiming', Val=>0, List=>[ 0, 1 ] ,
//;                       Doc=>"Should retiming be run in synthesis !FUNCTIONAL!");
//;   $retiming and $self->error( "Error: HACK-> Parameter may only be 0\n" ) ;
//; }
//;
//; if( $pipeline_depth > 1 ){
//;   parameter(Name=>'SmartRetiming', Val=>0, List=>[ 0, 1 ] , 
//;                       Doc=>"Retiming Should Force Multp to one cycle !IMPLEMENTATION!");
//; } 
//;
//; # And some local variables
//; my $product_width = 2 * $frac_width + 2;
//; my $wide_width = 4 * $frac_width  + 7; # 1 sign bit + (frac_width+1) + 2 guard bits + (2*frac_width+2) + (frac_width+1)
//;

module `mname` (
   //; if ($verif_mode =~ /ON/){
    input logic 				dumptolog,
   //; }
   input logic [`$exp_width + $frac_width`:0] 	a, b, c,
   //; if ($enable_forwarding =~ /YES/){
    input logic 				forward_a, forward_b, forward_c,
   //; }
    input logic [2:0] 				rnd,

   //; if ($pipeline_depth>0){
    input logic 				clk, reset, valid_in, stall_in, SI, SCAN_ENABLE, test_mode,
    output logic 				valid_out, SO,
   //; } else {
    input logic 				clk, reset,
   //; }
		
    output logic [`$exp_width + $frac_width`:0] z,
    output logic [7:0] status
           );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
     */



   
   
//; if( $desinware_mode eq 'ON' ){
  logic [`$exp_width + $frac_width`:0] 	a2, b2, c2;
  logic [2:0] 				rnd2;

//;   if($pipeline_depth > 0 ){
//;    my $fma_pipe = generate('Pinned_pipeline','fma_pipe', 
//;                         Width=> (3*$exp_width + 3*$frac_width + 6) , PipelineDepth=> $pipeline_depth);

  `$fma_pipe ->instantiate()` ( .in({a,b,c, rnd}) , .valid_in(valid_in), .clk(clk) , .stall(stall_in), .reset(reset), 
                                .out({a2,b2,c2, rnd2}), .valid_out(valid_out) );
//;   } else {
  assign {a2,b2,c2, rnd2} = {a,b,c, rnd};
//;   }

   DW_fp_mac #( `$frac_width` , `$exp_width` , `$enable_denormals eq 'YES' ?1:0` ) U1 (
									       .a(a2), .b(b2), .c(c2), .rnd(rnd2),
									       .z(z), .status(status) );
   
   
//; } elsif( $desinware_mode eq 'OFF'  ) {
    logic [`$exp_width + $frac_width`:0] z_preInc,z_preIncm;
    logic [`$product_width+1`:0] AB_pp0, AB_pp1, AB_pp0m, AB_pp1m;
    logic SignAB, NANAB, InfAB, ZeroAB, SignABm, NANABm, InfABm, ZeroABm;
    logic [`$wide_width-1`:0] shifted_C, shifted_Cm;
    logic SignC, NANC, InfC, ZeroC, SignCm, NANCm, InfCm, ZeroCm;
    logic [`$exp_width+1`:0] ExpBase, ExpBasem;
    logic [2:0] rndm;
    logic [7:0] statusm;
    logic IncZ, IncZm, valid_middle, valid_r, valid_inc;

//; my $fma_mulshift = generate('FMA_MulShift','MulShift', FractionWidth=> $frac_width , ExponentWidth=> $exp_width,
//;                          EnableDenormals=> $enable_denormals, EnableForwarding=> $enable_forwarding,
//;                          EnableMultiplePumping=> $enableMultiplePumping, PipelineDepth=> $mulp_pipeline_depth);

  `$fma_mulshift->instantiate()` (
   //; if ($verif_mode =~ /ON/){
       .dumptolog(dumptolog),
   //; }
       .a_in(a), .b_in(b), .c_in(c),
   //; if ($enable_forwarding =~ /YES/){
       .forward_a(forward_a), .forward_b(forward_b), .forward_c(forward_c),
   //; }
       .z_preInc(z_preIncm), .z_final(z), .IncZ(IncZm),
       .clk(clk) , .reset(reset), .valid_in(valid_in), .stall(stall_in),
       .AB_pp0(AB_pp0), .AB_pp1(AB_pp1), .SignAB(SignAB), .NANAB(NANAB), .InfAB(InfAB), .ZeroAB(ZeroAB),
       .shifted_C(shifted_C),.SignC(SignC), .NANC(NANC), .InfC(InfC), .ZeroC(ZeroC), 
       .ExpBase(ExpBase),
       .valid_out(valid_middle) );

//;  my $add_bus_width = $exp_width + 2*$product_width + $wide_width + 14;
//;  my $add_pipeline_depth = $pipeline_depth-$mulp_pipeline_depth-1;
//;  $add_pipeline_depth = $add_pipeline_depth<0? 0 : $add_pipeline_depth;
//;  my $add_pipe = ($enableMultiplePumping =~ /YES/)?
//;         generate('Pinned_pipeline', 'add_pipe', Width=> $add_bus_width , PipelineDepth=> $add_pipeline_depth)
//;       : generate('FF_pipeline', 'add_pipe', Width=> $add_bus_width, PipelineDepth=> $add_pipeline_depth, Retime=> 'YES');

  `$add_pipe ->instantiate()` (
       .in({AB_pp0, AB_pp1, SignAB, NANAB, InfAB, ZeroAB, shifted_C, SignC, NANC, InfC, ZeroC , ExpBase}) , 
       .valid_in(valid_middle), .clk(clk) , .stall(stall_in), .reset(reset), 
       .out({AB_pp0m,AB_pp1m,SignABm,NANABm,InfABm, ZeroABm, shifted_Cm, SignCm, NANCm, InfCm, ZeroCm, ExpBasem}),
       .valid_out(valid_inc) );


//;  if ($pipeline_depth>1) {
//;    my $rnd_pipe = generate('Pinned_pipeline','fma_pipe', Width=> 3, PipelineDepth=> $pipeline_depth-1);

  `$rnd_pipe ->instantiate()` (
       .in(rnd) , 
       .valid_in(valid_in), .clk(clk) , .stall(stall_in), .reset(reset), 
       .out(rndm),
       .valid_out(valid_r) );
//;  } else {
  assign rndm = rnd;
//;  }

//;  my $fma_add = generate('FMA_Add','add', FractionWidth=> $frac_width , ExponentWidth=> $exp_width,
//;                     EnableDenormals=> $enable_denormals);

  `$fma_add->instantiate()` (
      //; if ($verif_mode =~ /ON/){
    .dumptolog(dumptolog),
   //; }
    .AB_pp0(AB_pp0m), .AB_pp1(AB_pp1m), .SignAB(SignABm), .NANAB(NANABm), .InfAB(InfABm), .ZeroAB(ZeroABm),
    .shifted_C(shifted_Cm), .SignC(SignCm), .NANC(NANCm), .InfC(InfCm), .ZeroC(ZeroCm), 
    .ExpBase(ExpBasem), .rnd(rndm),
    .z(z_preIncm), .zinc(IncZm), .status(statusm) );


//;  if ($pipeline_depth-$mulp_pipeline_depth>0) {
//;    my $inc_pipe = $enable_forwarding =~ /YES/?
//;           generate('Pinned_pipeline','inc_pipe', Width=> $exp_width + $frac_width + 10 , PipelineDepth=> 1)
//;          :generate('FF_pipeline','inc_pipe', Width=> $exp_width + $frac_width + 10 , PipelineDepth=> 1, Retime=> 'YES');
  `$inc_pipe ->instantiate()` (
       .in({z_preIncm,IncZm, statusm}) , 
       .valid_in(valid_inc), .clk(clk) , .stall(stall_in), .reset(reset), 
       .out({z_preInc,IncZ,status}),
       .valid_out(valid_out) );
//;  } else {
  assign {z_preInc, IncZ, status} = {z_preIncm,IncZm, statusm};
//;  }



//;  my $fma_increment = generate('FPIncrementer','Incrementer', FractionWidth=> $frac_width , ExponentWidth=> $exp_width );

  `$fma_increment->instantiate()` (
   //; if ($verif_mode =~ /ON/){
    .dumptolog(dumptolog),
   //; }
    .a(z_preInc), .ainc(IncZ), .out(z) );




//; } #End Not Designware Loop



   //; if ($verif_mode =~ /ON/){
	// synopsys translate_off
	always @(posedge dumptolog)
	begin
		$display ("z = %h", z);
	end
	// synopsys translate_on
//; }
endmodule


