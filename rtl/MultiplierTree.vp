/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * MultiplierTree is a summation tree for PPCount partial products of PPWidth width.
 * 
 *                  
 * 
 * Parameters:
 * * PPWidth, BoothType, PPCount
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * Nov 01, 2011   shacham   Changed the column tree abstraction to  N*PPs, 
 * 			    N-3 or N-4 CI and N-3 CO.
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor rounding math
//; # use List::Util qw[min max]; # this library adds 10sec to compile time
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $pp_width = parameter(Name=>'PPWidth', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Bit width of the partial products");
//; my $pp_count = parameter(Name=>'PPCount', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products to sum");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>4, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $tree_type = parameter(Name=>'TreeType', Val=>'Wallace', List=>['Wallace','Array', 'ZM'],
//;                       Doc=>"Summation tree type. (Supported trees: Wallace, Array, ZM)");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; # Some variables initialization
//; my $width = $pp_width + $booth*($pp_count-1);  # add a booth width for every extra partial product

module `mname()` ( 
//; if ($verif_mode =~ /ON/){
    input logic 			dumptolog,
//; }
    input logic [`$pp_width-1`:0] 	pp [0:`$pp_count-1`],
    output logic [`$width-1`:0] 	out0,out1
   );

//;# uncomment to debug #   assign out1 = `$width`'b0;
//;# uncomment to debug #   assign out0 = 
//;# uncomment to debug #   //; for (my $i=0; $i<$pp_count;$i++){
//;# uncomment to debug #		 ({100'b0, pp[`$i`]} << `$booth*$i`)+
//;# uncomment to debug #   //; }
//;# uncomment to debug #		 `$width`'b0;
   
		 

   // Columns 0 through booth-1=`$booth-1` -- only one pp
   assign out0[`$booth-1`:0] =   pp[0][`$booth-1`:0];
   assign out1[`$booth-1`:0] = { (`$booth`){1'b0} };

   
   // Columns booth=`$booth` through 2*booth-1=`2*$booth-1` -- only two pp
   assign out0[`2*$booth-1`:`$booth`] = pp[0][`2*$booth-1`:`$booth`];
   assign out1[`2*$booth-1`:`$booth`] = pp[1][`$booth-1`:0];

   // From this column=`2*$booth` on, we need summation trees which will generate sum and carry
   // Since at column J, sum goes to out0[J] and carry to out1[J+1] we need to assign
   // a zero to out1[`2*$booth`]
   assign out1[`2*$booth`] = 1'b0;
   
   /* *
    * Typically, every column tree should have N partial products, N-3 carry in and N-3 carry out. But...
    * When this column is higher than the prev column (going up) ==> we are missing one ci
    * When this column is the first column to be shorter than the prev column => we have one extra ci
    * When this column is on the downward slope but the same height as the prev => we have one extra ci
    * When this is the downward slope and this column is shorter than the prev column => we have two extra ci
    * */

//; my $ci_w = 0;
//; my $co_w = 0;
//; for (my $j = 2*$booth; $j < $width-$booth; $j++) {
//;   my $first_row = ($j < $pp_width)?  0 : ceil(($j+1-$pp_width)/$booth);
//;   my $last_row = ( floor($j/$booth) < $pp_count-1) ? floor($j/$booth) : $pp_count-1;  #min( floor($j/$booth), $pp_count-1);
//;   my $pp_col_ht = $last_row - $first_row + 1;
//;
//;   # There are five distinct cases:
//;   my $up = ($first_row==0 && $j%$booth==0 && floor($j/$booth)<=$pp_count-1)? 1:0; 	 # this column has one more pp than prev column
//;   my $up_even = ($first_row==0 && $up==0)? 1:0; 		 	# this coulmn has same hight as prev column but 
//;								 	# we are still at the increasing side of the parallelogram
//;   my $down_first  = ($first_row==1 && ($j-$pp_width)%$booth==0)? 1:0;# First time a column is shorter than its prev column 
//;   my $down  = ($first_row>1 && ($j-$pp_width)%$booth==0)? 1:0;	# this column has one less pp than prev column
//;   my $down_even = ($first_row>0 && ($j-$pp_width)%$booth!=0)? 1:0;	# this coulmn has same hight as prev column but 
//;								 	# we are at the decreasing side of the parallelogram
//;
//;   print STDERR "DEBUG: booth=$booth col=$j first_row=$first_row last_row=$last_row hight=$pp_col_ht\n";
//;   print STDERR "DEBUG: up=$up up_even=$up_even down=$down down_first=$down_first down_even=$down_even\n";
//;   $self->error("More than one flag at once: up=$up up_even=$up_even down_first=$down_first down=$down down_even=$down_even")
//;		if ($up+$up_even+$down_first+$down+$down_even != 1);
//;
   
      // Now working on column J=`$j` of hight `$pp_col_ht`
      // For this column: up=`$up` up_even=`$up_even` down_first=`$down_first` down_even=`$down_even` down=`$down`
      logic [`$pp_col_ht-1`:0] pp_col`$j`;
//;   my $pp_idx = 0;
//;   for(my $row=$first_row; $row <= $last_row; $row++){
        assign pp_col`$j`[`$pp_idx++`] = pp[`$row`][`$j-$row*$booth`];
//;   }

//;   my $ci_flag = 'Normal';
//;   $ci_flag = 'OneMissing' if $up && $pp_col_ht>3;		$ci_w = $pp_col_ht-4 if $up;
//;   $ci_flag = 'Normal' if $up_even;    			$ci_w = $pp_col_ht-3 if $up_even;
//;   $ci_flag = 'OneExtra' if $down_first || $down_even;	$ci_w = $pp_col_ht-2 if $down_first || $down_even;
//;   $ci_flag = 'TwoExtra' if $down;  				$ci_w = $pp_col_ht-1 if $down;
//;   $ci_w = 0 if ($ci_w < 0); # can't have negative width
//;   if ($ci_w){
        logic [`$ci_w-1`:0] ci_col`$j`; // carry in to column j=`$j` (to extracted from co of `$j-1`)
          assign ci_col`$j`[`$ci_w-1`:0] = co_col`$j-1`[`$co_w-1`:0];
//;   }

//;   $co_w = $pp_col_ht-3 if $up || $up_even;
//;   $co_w = $pp_col_ht-2 if $down_first || $down || $down_even;
//;   $co_w = 0 if ($co_w < 0); # can't have negative width
//;   if($co_w){
      logic [`$co_w-1`:0] co_col`$j`; // carry out of column j=`$j` (to be driven as carry in to `$j+1`)
//;   }
   
//;   # generate the needed column tree
//;   my $treecolumn_obj = generate("${tree_type}Column", "column_$j", 
//;     			     LayoutShape=> $layout_shape, 
//;     			     ColumnHight=> $pp_col_ht, 
//;      			     ColumnPosition=> $j, 
//;       			     MinRow=> $first_row, 
//;       			     BoothType => $booth,
//;        			     CarryInFlag => $ci_flag);
//;
      // Instantiate collumn `$j` summation tree: pp_width=`$pp_width` first_row=`$first_row` last_row=`$last_row` hight=`$pp_col_ht`
      `$treecolumn_obj->instantiate()`  (.pp(pp_col`$j`),
					 //;   if ($ci_w){
                                         .ci(ci_col`$j`),                                     
					 //;   }
					 //;   if($co_w){
                                         .co(co_col`$j`),
					 //;   }
                                         .sum(out0[`$j`]), .carry(out1[`$j+1`]));

//;   # Get ready for next iteration:
//; }
  
   // Columns `$width-$booth` through `$width-1` -- only one pp again 
   // Note that out1[`$width-$booth`] was already assigned so only need `$width-$booth+1` through `$width-1`
   assign out0[`$width-1`:`$width-$booth`] =   pp[`$pp_count-1`][`$pp_width-1`:`$pp_width-$booth`];
//; if ($width-1 >= $width-$booth+1){
   assign out1[`$width-1`:`$width-$booth+1`] = { (`$booth-1`){1'b0} };
//; }



   
    
//; if ($verif_mode =~ /ON/){
	// synopsys translate_off
	always @(posedge dumptolog)
	begin
		$display ("`mname`: out0 = %b", out0);
		$display ("`mname`: out1 = %b", out1);
	end
	// synopsys translate_on

 //; }
endmodule


