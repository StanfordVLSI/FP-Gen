/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/MultiplierTree.vp#4 $
 ** $DateTime: 2011/10/06 15:10:49 $
 ** $Change: 9561 $
 ** $Author: sameh $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * MultiplierTree is a summation tree for PPCount partial products of PPWidth width.
 * 
 *                  
 * 
 * Parameters:
 * * PPWidth, BoothType, PPCount
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor rounding math
//; use List::Util qw[min max];
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $pp_width = parameter(Name=>'PPWidth', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Bit width of the partial products");
//; my $pp_count = parameter(Name=>'PPCount', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products to sum");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $tree_type = parameter(Name=>'TreeType', Val=>'Wallace', List=>['Wallace','Array'],
//;                       Doc=>"Summation tree type. (Supported trees: Wallace, Array)");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; # Some variables initialization
//; my $width = $pp_width + $booth*($pp_count-1);  # add a booth width for every extra partial product

module `mname()` ( 
//; if ($verif_mode =~ /ON/){
    input logic 			dumptolog,
//; }
    input logic [`$pp_width-1`:0] 	pp [0:`$pp_count-1`],
    output logic [`$width-1`:0] 	out0,out1
   );



   // Columns 0 through booth-1=`$booth-1` -- only one pp
   assign out0[`$booth-1`:0] =   pp[0][`$booth-1`:0];
   assign out1[`$booth-1`:0] = { (`$booth`){1'b0} };

   
   // Columns booth=`$booth` through 2*booth-1=`2*$booth-1` -- only two pp
   assign out0[`2*$booth-1`:`$booth`] = pp[0][`2*$booth-1`:`$booth`];
   assign out1[`2*$booth-1`:`$booth`] = pp[1][`$booth-1`:0];

   // From this column=`2*$booth` on, we need summation trees which will generate sum and carry
   // Since at column J, sum goes to out0[J] and carry to out1[J+1] we need to assign
   // a zero to out1[`2*$booth`]
   assign out1[`2*$booth`] = 0'b0;
   

//; my $ci_w = 0;
//; my $co_w = 0;
//; for (my $j = 2*$booth; $j < $width-$booth-1; $j++) {
//;   my $first_row = ($j < $pp_width)?  0 : ceil(($j+1-$pp_width)/$booth);
//;   my $last_row = min( floor($j/$booth), $pp_count-1);
//;   my $col_ht = $last_row - $first_row + 1;
   // Now working on column J=`$j` of hight `$col_ht`
   //; print STDERR "DEBUG: booth=$booth col=$j first_row=$first_row last_row=$last_row hight=$col_ht\n";
//;
//;   # first we generate the needed column
//;   my $treecolumn_obj = generate("${tree_type}Column", "column_$j", 
//;     			     LayoutShape=> $layout_shape, 
//;     			     ColumnHight=> $col_ht, 
//;      			     ColumnPosition=> $j, 
//;       			     MinRow=> $first_row, 
//;       			     BoothType => $booth,
//;        			     CarryInWidth => $ci_w);
//;
//;   # after it was generated we can extract the carry out width to prepare the co signal
//;   $co_w = $treecolumn_obj->get_param('CarryOutWidth');
//;   if($co_w){
      logic [`$co_w-1`:0] c_col`$j`; // carry out of column j=`$j` (to be driven as carry in to j+1)
//;   }

      // instantiate collumn `$j` summation tree: pp_width=`$pp_width` first_row=`$first_row` last_row=`$last_row` hight=`$col_ht`
      `$treecolumn_obj->instantiate()`  (.pp( { pp[`$last_row`][`$j-$last_row*$booth`]
						//;   for(my $row=$last_row-1; $row >= $first_row; $row--){
						, pp[`$row`][`$j-$row*$booth`]
						//;   }
						} ),
					 //;   if ($ci_w){
                                         .ci(c_col`$j-1`),                                     
					 //;   }
					 //;   if($co_w){
                                         .co(c_col`$j`),
					 //;   }
                                         .sum(out0[`$j`]), .carry(out1[`$j+1`]));

//;   # Get ready for next iteration:
//;   $ci_w = $co_w; 
//; }
  
   // Columns `$width-$booth-1` through `$width-1` -- only one pp again
   assign out0[`$width-1`:`$width-$booth-1`] =   pp[`$pp_count-1`][`$booth-1`:0];
   assign out1[`$width-1`:`$width-$booth`] = { (`$booth-1`){1'b0} };

//; if ($verif_mode =~ /ON/){
	// synopsys translate_off
	always @(posedge dumptolog)
	begin
		$display ("`mname`: out0 = %b", out0);
		$display ("`mname`: out1 = %b", out1);
	end
	// synopsys translate_on

 //; }
endmodule


