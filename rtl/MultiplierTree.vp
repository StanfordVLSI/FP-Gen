/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/MultiplierTree.vp#4 $
 ** $DateTime: 2011/10/06 15:10:49 $
 ** $Change: 9561 $
 ** $Author: sameh $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * MultiplierTree is a summation tree for PPCount partial products of PPWidth width.
 * 
 *                  
 * 
 * Parameters:
 * * PPWidth, BoothType, PPCount
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * Nov 01, 2011   shacham   Changed the column tree abstraction to  N*PPs, 
 * 			    N-3 or N-4 CI and N-3 CO.
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor rounding math
//; # use List::Util qw[min max]; # this library adds 10sec to compile time
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $pp_width = parameter(Name=>'PPWidth', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Bit width of the partial products");
//; my $pp_count = parameter(Name=>'PPCount', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products to sum");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $tree_type = parameter(Name=>'TreeType', Val=>'Wallace', List=>['Wallace','Array'],
//;                       Doc=>"Summation tree type. (Supported trees: Wallace, Array)");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; # Some variables initialization
//; my $width = $pp_width + $booth*($pp_count-1);  # add a booth width for every extra partial product

module `mname()` ( 
//; if ($verif_mode =~ /ON/){
    input logic 			dumptolog,
//; }
    input logic [`$pp_width-1`:0] 	pp [0:`$pp_count-1`],
    output logic [`$width-1`:0] 	out0,out1
   );



   // Columns 0 through booth-1=`$booth-1` -- only one pp
   assign out0[`$booth-1`:0] =   pp[0][`$booth-1`:0];
   assign out1[`$booth-1`:0] = { (`$booth`){1'b0} };

   
   // Columns booth=`$booth` through 2*booth-1=`2*$booth-1` -- only two pp
   assign out0[`2*$booth-1`:`$booth`] = pp[0][`2*$booth-1`:`$booth`];
   assign out1[`2*$booth-1`:`$booth`] = pp[1][`$booth-1`:0];

   // From this column=`2*$booth` on, we need summation trees which will generate sum and carry
   // Since at column J, sum goes to out0[J] and carry to out1[J+1] we need to assign
   // a zero to out1[`2*$booth`]
   assign out1[`2*$booth`] = 1'b0;
   

//; my $ci_w = 0;
//; my $co_w = 0;
//; for (my $j = 2*$booth; $j < $width-$booth; $j++) {
//;   my $first_row = ($j < $pp_width)?  0 : ceil(($j+1-$pp_width)/$booth);
//;   my $last_row = ( floor($j/$booth) < $pp_count-1) ? floor($j/$booth) : $pp_count-1;  #min( floor($j/$booth), $pp_count-1);
//;   my $pp_col_ht = $last_row - $first_row + 1;
//;
//;   # There are five distinct cases:
//;   my $up = ($first_row==0 && $j%$booth==0 && floor($j/$booth)<=$pp_count-1)? 1:0; 	 # this column has one more pp than prev column
//;   my $up_even = ($first_row==0 && $up==0)? 1:0; 		 	# this coulmn has same hight as prev column but 
//;								 	# we are still at the increasing side of the parallelogram
//;   my $down  = ($first_row>0 && ($j-$pp_width)%$booth==0)? 1:0;	# this column has one less pp than prev column
//;   my $down_first  = ($first_row==1 && $down==1)? 1:0;		# First time a column is shorter than its prev column
//;   my $down_even = ($first_row>0 && $down==0)? 1:0;			# this coulmn has same hight as prev column but 
//;								 	# we are at the decreasing side of the parallelogram
//;
//;   my $tree_col_ht = $pp_col_ht;		# That's the actuall tree we are building (which may have an extra PP from ci)
//;   $tree_col_ht += 1 if $first_row>0 && $co_w>0;	# At the 'going down' side of the parallelogram, 
//;			 			 	# we always put ci[0] or ci[last] as first or last pp, but only if
//;			 			 	# there is co from the previous column
//;
//;    ## print STDERR "DEBUG: booth=$booth col=$j first_row=$first_row last_row=$last_row hight=$pp_col_ht\n";
//;    ## print STDERR "DEBUG: up=$up up_even=$up_even down=$down down_first=$down_first down_even=$down_even\n";
//;
      // Now working on column J=`$j` of hight `$pp_col_ht`
      logic [`$tree_col_ht-1`:0] pp_col`$j`;
//;   my $pp_idx = 0;
//;   if ($down){
        assign pp_col`$j`[`$pp_idx++`] = co_col`$j-1`[0]; // use LSB of co of previous column as a pp
//;   }
//;   for(my $row=$first_row; $row <= $last_row; $row++){
        assign pp_col`$j`[`$pp_idx++`] = pp[`$row`][`$j-$row*$booth`];
//;   }  
//;   if ($down_even && $co_w){
        assign pp_col`$j`[`$pp_idx++`] = co_col`$j-1`[`$co_w-1`]; // use MSB of co of previous column as a pp
//;   }
//;   $self->error("How come pp_idx($pp_idx) != tree_col_ht($tree_col_ht)?") if $pp_idx!=$tree_col_ht;

//;   $ci_w = ($up || $down_even || $down_first) ? $tree_col_ht-4:$tree_col_ht-3;
//;   $ci_w = 0 if ($ci_w < 0); # can't have negative width
//;   if ($ci_w){
        logic [`$ci_w-1`:0] ci_col`$j`; // carry in to column j=`$j` (to extracted from co of `$j-1`)
//;     if ($down){
          assign ci_col`$j`[`$ci_w-1`:0] = co_col`$j-1`[`$co_w-1`:1]; // since we used the LSB of co of previous column as a pp
          //; $self->error("down col $j: ci_w($ci_w)!=co_w-1($co_w-1)") if $ci_w!=$co_w-1;
//;     }elsif ($down_even){
          assign ci_col`$j`[`$ci_w-1`:0] = co_col`$j-1`[`$co_w-2`:0]; // since we used the MSB of co of previous column as a pp
          //; $self->error("down_even col $j: ci_w($ci_w)!=co_w-1($co_w-1)") if $ci_w!=$co_w-1;
//;     }else{
          assign ci_col`$j`[`$ci_w-1`:0] = co_col`$j-1`[`$co_w-1`:0];
          //; $self->error("else col $j: ci_w($ci_w)!=co_w($co_w)") if $ci_w!=$co_w;
//;     }
//;   }

//;   $co_w = ($tree_col_ht>3) ? $tree_col_ht-3:0;
//;   if($co_w){
      logic [`$co_w-1`:0] co_col`$j`; // carry out of column j=`$j` (to be driven as carry in to `$j+1`)
//;   }
   
//;   # generate the needed column tree
//;   my $treecolumn_obj = generate("${tree_type}Column", "column_$j", 
//;     			     LayoutShape=> $layout_shape, 
//;     			     ColumnHight=> $tree_col_ht, 
//;      			     ColumnPosition=> $j, 
//;       			     MinRow=> $first_row, 
//;       			     BoothType => $booth,
//;        			     OneLessCarryIn => $up || $down_even || $down_first);
//;
      // Instantiate collumn `$j` summation tree: pp_width=`$pp_width` first_row=`$first_row` last_row=`$last_row` hight=`$pp_col_ht`
      `$treecolumn_obj->instantiate()`  (.pp(pp_col`$j`),
					 //;   if ($ci_w){
                                         .ci(ci_col`$j`),                                     
					 //;   }
					 //;   if($co_w){
                                         .co(co_col`$j`),
					 //;   }
                                         .sum(out0[`$j`]), .carry(out1[`$j+1`]));

//;   # Get ready for next iteration:
//; }
  
   // Columns `$width-$booth` through `$width-1` -- only one pp again 
   // Note that out1[`$width-$booth`] was already assigned so only need `$width-$booth+1` through `$width-1`
   assign out0[`$width-1`:`$width-$booth`] =   pp[`$pp_count-1`][`$pp_width-1`:`$pp_width-$booth`];
//; if ($width-1 >= $width-$booth+1){
   assign out1[`$width-1`:`$width-$booth+1`] = { (`$booth-1`){1'b0} };
//; }
   
//; if ($verif_mode =~ /ON/){
	// synopsys translate_off
	always @(posedge dumptolog)
	begin
		$display ("`mname`: out0 = %b", out0);
		$display ("`mname`: out1 = %b", out1);
	end
	// synopsys translate_on

 //; }
endmodule


