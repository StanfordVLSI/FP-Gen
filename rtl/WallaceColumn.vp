/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/WallaceColumn.vp#1 $
 ** $DateTime: 2011/10/06 15:10:49 $
 ** $Change: 9561 $
 ** $Author: sameh $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a WallaceColumn that process a vertical slice in multiplication tree 
 * using a Wallace tree architecture
 *
 * Parameters:
 * * PPCount
 *
 * Inputs:
 * * PPCount inputs                
 * * (PPCount-1) ci
 * 
 * Outputs:
 * * sum
 * * carry
 * * (PPCount-2) co
 *
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 23, 2011   Sameh     initial version ported from Ofer's Wallace
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor); # For floor rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters

//; my $pp_count = parameter(Name=>'PPCount', Val=>4, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products to sum");
//; my $col = parameter(Name=>'ColumnPosition', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The column number");
//; my $min_row = parameter(Name=>'MinRow', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The starting row position");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");

module `mname()` (
    input logic [`$pp_count-1`:0] pp,
    output logic sum, carry,
    input logic  [`$pp_count-2`:0] ci
//;if($pp_count>2){
    , output logic [`$pp_count-3`:0] co
//;}
   );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */


   //; my @occupied_idx =();
   //; for  (my $i=0; $i < $pp_count-1 ; $i++){
   //;   $occupied_idx[$i]=0;
   //; } 

   //; my $step = 0;
   //; my $hight = $pp_count + 1;
       logic [`$hight-1`:0] pp_step`$step`;
       assign pp_step`$step` = {pp,ci[0]};

   //; if ($hight>3){
       logic [`$hight-4`:0] wallace_ci;
       assign wallace_ci= ci[`$pp_count-2`:1];
   //;}

   //; my $csa_idx = 0;
   //; while($hight > 2){
   //;   $step++;
   //;   my $next_hight = 2 * floor($hight/3) + $hight%3;
       logic [`$next_hight-1`:0] pp_step`$step`;

   //;   for (my $i=0; $i < floor($hight/3); $i++){
   //;
   //;     my $row_candidate = floor($i/floor($hight/3) * ($pp_count-2));
   //;     my $row_candidate_up = $row_candidate;
   //;     my $row_candidate_down = $row_candidate;
   //;     while ( $row_candidate_up < $pp_count-1 || $row_candidate_down>=0){
   //;       if ($row_candidate_up<$pp_count-1){
   //;          if ($occupied_idx[$row_candidate_up]==0){
   //;            $row_candidate = $row_candidate_up;
   //;            $row_candidate_up=$pp_count-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_up++;
   //;          }
   //;       }
   //;       if ($row_candidate_down>=0){
   //;          if ($occupied_idx[$row_candidate_down]==0){
   //;            $row_candidate = $row_candidate_down;
   //;            $row_candidate_up=$pp_count-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_down--;
   //;          }
   //;       }
   //;     }
   //;     $occupied_idx[$row_candidate] = 1;
   //;     my $row = $min_row + $row_candidate;
   //;
   //;     my $Y = $col - $row * $booth; 
   //;     my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
      `$CSA_obj->instantiate()` ( .a(pp_step`$step-1`[`3*$i`]), .b(pp_step`$step-1`[`3*$i+1`]), .ci(pp_step`$step-1`[`3*$i+2`]),
   //;     if ($next_hight>2){
                                  .s(pp_step`$step`[`2*$i`]), .co(co[`$csa_idx`]) );
       assign pp_step`$step`[`2*$i+1`] = wallace_ci[`$csa_idx`];
   //;     }else{
                                  .s(sum), .co(carry) );
   //;     }
   //;     $csa_idx++;
   //;   }

   //;   for (my $i=3 * floor($hight/3); $i < $hight; $i++){
       assign pp_step`$step`[`$i-floor($hight/3)`] = pp_step`$step-1`[`$i`];
   //;   }
   //;   $hight=$next_hight;
   //; } 


endmodule


