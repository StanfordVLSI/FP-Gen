/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a ArrayColumn that process a vertical slice in multiplication tree 
 * using a Wallace architecture
 *
 * Parameters:
 * * ColumnHight, ColumnPosition, MinRow, BoothType, CarryInFlag, LayoutShape,
 * * PrevColumn (pointer to the previous column object)
 * 
 * Note that if:
 * CarryInFlag == Normal ==> ci_w=N-3 , co_w=N-3
 * CarryInFlag == OneMissing ==> ci_w=N-4 , co_w=N-3
 * CarryInFlag == OneExtra ==> ci_w=N-2 , co_w=N-2
 * CarryInFlag == TwoExtra ==> ci_w=N-1 , co_w=N-2
 *
 * Inputs:
 * * Given that N=ColumnHight
 * * [N-1:0] pp                 
 * * [ci_w-1:0] ci
 *  
 * Outputs:
 * * sum
 * * carry
 * * [co_w-1:0] co
 *
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 21, 2011   Sameh     initial version
 * Nov 01, 2011   shacham   Changed the abstraction to the N*PPs, N-3 or N-4 CI 
 * 			    and N-3 CO.
 * Nov 23, 2011   shacham   new abstraction using CarryInFlag=OneMissing/Normal/
 * 			    OneExtra/TwoExtra
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor and ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $col_ht = parameter(Name=>'ColumnHight', Val=>2, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products in relevant column to sum");
//; my $col = parameter(Name=>'ColumnPosition', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The column number");
//; my $min_row = parameter(Name=>'MinRow', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The starting row position");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>4, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $ci_flag = parameter(Name=>'CarryInFlag', Val=>'Normal', List=>['Normal','OneMissing','OneExtra','TwoExtra'],
//;                      Doc=>"Is there one less carry in for this column? or maybe one or two more? (Normal is ColumnHight-3)");
//; my $prev_col = parameter(Name=>'PrevColumn', Val=>-1, 
//;			     Doc=>"Pointer to the previous column of the multiplier ".
//;				  "(must be assigned or set to zero at instantiation!)");
//; $self->error("Parameter PrevColumn must be assigned with a pointer to a Wallace column or 0 (zero)!")
//;          unless $prev_col || $prev_col==0;
//; my $prev_csa_arr_ptr = [];
//; if ($prev_col){
//;   $prev_csa_arr_ptr = $prev_col->get_param('CSAArr');
//; }
//; my @prev_csa_arr = @{$prev_csa_arr_ptr}; # dereference the array pointer
//; my @csa_arr = ();
//;
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//;
//; my $ci_w = 0; my $co_w = 0; 
//; $ci_w = $col_ht-4 if $ci_flag =~ /OneMissing/;
//; $ci_w = $col_ht-3 if $ci_flag =~ /Normal/;
//; $ci_w = $col_ht-2 if $ci_flag =~ /OneExtra/;
//; $ci_w = $col_ht-1 if $ci_flag =~ /TwoExtra/;
//; $ci_w = 0 if ($ci_w < 0); # can't have negative width
//;
//; $co_w = $col_ht-3 if $ci_flag =~ /OneMissing/;
//; $co_w = $col_ht-3 if $ci_flag =~ /Normal/;
//; $co_w = $col_ht-2 if $ci_flag =~ /OneExtra/;
//; $co_w = $col_ht-2 if $ci_flag =~ /TwoExtra/;
//; $co_w = 0 if ($co_w < 0); # can't have negative width
//;
//; # print STDERR "DEBUG: hight=$col_ht, col=$col, min_row=$min_row, booth=$booth, ci_w=$ci_w, co_w=$co_w \n";

module `mname()` (
    input logic [`$col_ht-1`:0] pp,
//; if($ci_w){
    input logic  [`$ci_w-1`:0] ci,
//; }
//;if($co_w){
    output logic [`$co_w-1`:0] co,
//;}
    output logic sum, carry
   );

  /* synopsys dc_tcl_script_begin
   set_ungroup [current_design] true
   set_flatten true -effort high -phase true -design [current_design]
  */

   //; # Initial key indices etc.
   //; my @occupied_idx =();
   //; for  (my $i=0; $i < $col_ht-1 ; $i++){
   //;   $occupied_idx[$i]=0;
   //; }
   //; my $row = 0; my $Y=0;
   //; my $step = 0;
   //; my $hight = $col_ht;
   //; my $csa_idx = 0;
   //; my $typical_ci_w = $col_ht-3; # this is the max ci in a typical tree

   
   
   // First, lets define some internal signal conventions:
   //; if ($hight==2 && $ci_w==1){
   //;   # This is a corner case where there is really nothing to do but
   //;   # stick the ci to the first csa
   logic [`$hight`:0] pp_step`$step`;
   assign pp_step`$step` = {pp,ci};
   //;   $hight+=1; $ci_w-=1; # updating the indices to complete the cheat :-\
   //; }else{
   logic [`$hight-1`:0] pp_step`$step`;
   assign pp_step`$step` = pp;
   //; }
   
   //;   if($ci_w){
     logic [`$ci_w-1`:0] 	wallace_ci;
     assign wallace_ci = ci;
   //;   }
   logic [`$co_w`:0] wallace_co;


   //; while($hight > 1){
   //;   $step++;
   //;   push(@csa_arr, 0);
   //;   my $missing_last_ci=0;
   //;   my $max_i = ($hight==2)? 1 : floor($hight/3);
   //;   my $next_hight = ($hight==2)? 1 : 2 * floor($hight/3) + $hight%3;
   // Starting Level `$step` of the tree. Hight=`$hight` EstimatedNextHight=`$next_hight`
      logic [`$next_hight-1`:0] pp_step`$step`; // For holding results of level `$step`

   //;   for (my $i=0; $i < $max_i; $i++){
   //;
   //;     ######### Calculate Cell Location ##########
   //;     my $row_candidate = floor($i/$max_i * ($col_ht-2));
   //;     my $row_candidate_up = $row_candidate;
   //;     my $row_candidate_down = $row_candidate;
   //;     while ( $row_candidate_up < $col_ht-1 || $row_candidate_down>=0){
   //;       if ($row_candidate_up<$col_ht-1){
   //;          if ($occupied_idx[$row_candidate_up]==0){
   //;            $row_candidate = $row_candidate_up;
   //;            $row_candidate_up=$col_ht-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_up++;
   //;          }
   //;       }
   //;       if ($row_candidate_down>=0){
   //;          if ($occupied_idx[$row_candidate_down]==0){
   //;            $row_candidate = $row_candidate_down;
   //;            $row_candidate_up=$col_ht-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_down--;
   //;          }
   //;       }
   //;     }
   //;     $occupied_idx[$row_candidate] = 1;
   //;     $row = $min_row + $row_candidate;
   //;
   //;     $Y = $col - $row * $booth  if $layout_shape =~ /Square/;
   //;     $Y = $col if $layout_shape =~ /Parallelogram/;
   //;     ##########################################
   //;
   //;     ########### Instantiate Cell #############
   //;     if ($hight>2) {
   //;       my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   //;       $csa_arr[$step-1]++;
      `$CSA_obj->instantiate()` ( .a(pp_step`$step-1`[`3*$i`]), .b(pp_step`$step-1`[`3*$i+1`]), .ci(pp_step`$step-1`[`3*$i+2`]),
                                  .s(pp_step`$step`[`2*$i`]), .co(wallace_co[`$csa_idx`]) );
   //;     } else {
   //;       my $CSA_obj = generate('HA', "csa_${row}_${Y}");
   //;       $csa_arr[$step-1]++;
      `$CSA_obj->instantiate()` ( .a(pp_step`$step-1`[`3*$i`]), .b(pp_step`$step-1`[`3*$i+1`]),
                                  .s(pp_step`$step`[`2*$i`]), .co(wallace_co[`$csa_idx`]) );
   //;     }
   //;     $missing_last_ci = ($csa_idx >= $ci_w || $csa_idx>=$typical_ci_w);
   //;     if (!$missing_last_ci){
      assign pp_step`$step`[`2*$i+1`] = wallace_ci[`$csa_idx`];
   //;     }
   //;     $csa_idx++; 
   //;   } # End of "for (my $i=0; $i < flo..."

   //;   for (my $i=3 * $max_i; $i < $hight; $i++){
       // copy the leftovers to the next level
       assign pp_step`$step`[`$i-floor($hight/3)-$missing_last_ci`] = pp_step`$step-1`[`$i`];
   //;   }
   

   //;   $hight=$next_hight-$missing_last_ci;
   //; } # End of "while($hight > 2){..."


   //; if($ci_w>=$col_ht-2 && $ci_w>0){
   //;     ######### Calculate Final Cell Location ##########
   //;     my $row_candidate = $col_ht-1;
   //;     my $row_candidate_up = $row_candidate;
   //;     my $row_candidate_down = $row_candidate;
   //;     while ( $row_candidate_up < $col_ht-1 || $row_candidate_down>=0){
   //;       if ($row_candidate_up<$col_ht-1){
   //;          if ($occupied_idx[$row_candidate_up]==0){
   //;            $row_candidate = $row_candidate_up;
   //;            $row_candidate_up=$col_ht-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_up++;
   //;          }
   //;       }
   //;       if ($row_candidate_down>=0){
   //;          if ($occupied_idx[$row_candidate_down]==0){
   //;            $row_candidate = $row_candidate_down;
   //;            $row_candidate_up=$col_ht-1; $row_candidate_down=-1;
   //;          } else {
   //;            $row_candidate_down--;
   //;          }
   //;       }
   //;     }
   //;     $occupied_idx[$row_candidate] = 1;
   //;     $row = $min_row + $row_candidate;
   //;
   //;     $Y = $col - $row * $booth  if $layout_shape =~ /Square/;
   //;     $Y = $col if $layout_shape =~ /Parallelogram/;
   //;     ##########################################
   //; }
   //;
   //; if ($ci_w==$col_ht-2 && $ci_w>0){
   /* We have one extra ci that we could not use until now... bummer. We'll add 
    * it at the end using one last half adder. But don't feel too bad -- since 
    * it means that this column is shorter than those before it, so one extra HA
    * won't kill us... I think :-<>
    * */
   //;   $step++;
   //;   push(@csa_arr, 0);
   logic [0:0] 	 pp_step`$step`;
   //;   my $CSA_obj = generate('HA', "csa_${row}_${Y}");
   //;   $csa_arr[$step-1]++;
   `$CSA_obj->instantiate()` ( .a(pp_step`$step-1`[0]), .b(wallace_ci[`$ci_w-1`]),
                               .s(pp_step`$step`[0]), .co(wallace_co[`$csa_idx`]) );
   //;   $csa_idx++;
   //; }
   //;
   //; if ($ci_w==$col_ht-1 && $ci_w>0){
   /* We have two extra ci that we could not use until now... bummer. We'll add 
    * it at the end using one last full adder. But don't feel too bad -- since 
    * it means that this column is shorter than those before it, so one extra FA
    * won't kill us... I think :-<>
    * */
   //;   $step++;
   //;   push(@csa_arr, 0);
   logic [0:0] 	 pp_step`$step`;
   //;   my $CSA_obj = generate('CSA', "csa_${row}_${Y}");
   //;   $csa_arr[$step-1]++;
   `$CSA_obj->instantiate()` ( .a(pp_step`$step-1`[0]), .b(wallace_ci[`$ci_w-1`]), .ci(wallace_ci[`$ci_w-2`]),
                               .s(pp_step`$step`[0]), .co(wallace_co[`$csa_idx`]) );
   //;   $csa_idx++; 
   //; }
   
   assign carry = wallace_co[`$co_w`];
   assign sum = pp_step`$step`[0];
   //; if ($co_w){
   assign co = wallace_co[`$co_w-1`:0];
   //; }


endmodule

//; # Declare the current csa_arr for other modules to use
//; parameter(Name=>'CSAArr', Val=>\@csa_arr, Force=>1,
//;	      Doc=>"Array of number of CSAs per level of the tree");
