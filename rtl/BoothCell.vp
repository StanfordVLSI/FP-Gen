/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * Single cell for Booth encoding for a multiplier. Produce one bit of one
 * partial product.
 * 
 * 
 * Parameters:
 * -----------
 * * BoothType -- for booth 3 and above
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Nov 11, 2011   shacham   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//;
//;
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $booth = parameter(Name=>'BoothType', Val=>2, Min=>2, Step=>1, Max=>8,
//;                       Doc=>"Booth type. Required parameter at instantiation.");
//; my $invert_sel = parameter(Name=>'InvertSel', Val=>'YES', List=>['YES', 'NO'],
//;                       Doc=>"denotes if the select signals are inverted or not");
//;
//; my $num_inputs = 2**($booth-1);
//; sub IsPowOfTwo {
//;   my $num = shift or die;
//;   return 1 if $num==0 || $num==1 || $num==2 || $num==4 || $num==8 || $num==16 || $num==32 || $num==64;
//; }




module `mname` (
    input logic [`$num_inputs`:0]  sel_x, //MSB is a sign bit while others are 1 hot mux for selecting 1-`2**($booth-1)` X
    input logic [`$num_inputs-1`:0]  x, 
   //;if ($booth==2) {
    input logic xn1,
    output logic xn0,
   //;}
    output logic 		pp               	// single bit of the relevant pp
		);

   logic [`$num_inputs-1`:0] sel_x_local;
  //; if ($invert_sel =~ /YES/){
   assign sel_x_local = ~ sel_x[`$num_inputs-1`:0];
  //; } else {
   assign sel_x_local = sel_x[`$num_inputs-1`:0] ;
  //; }

   logic sign_x;
   assign sign_x = sel_x[`$num_inputs`];

   //;if ($booth==2) {
   assign xn0 = ~ sign_x ^ x[0];
   assign pp = ~((~sel_x_local[0] | xn0) & (~sel_x_local[1] | xn1));

   //;} else {

   logic pp_pow2; // this is for early signals such as 0, x, 2*x, 4*x, 8*x
   logic pp_all;  // this is for late signals such as x3 x5 and x7

   // Mux 0, x1, x2, x4, x8 based on the edge vector
   //;   my $str = '';
   //;   for (my $i=0; $i<$num_inputs; $i++){
   //;     $str = $str." (~sel_x_local[${i}] | ~x[${i}])" if IsPowOfTwo($i+1);
   //;     $str = $str." &" if $i+1<$num_inputs && IsPowOfTwo($i+1);
   //;   }
   assign pp_pow2 = `$str`;
 
   // Mux pp_pow2 and other multiples of x
   //;   $str = '';
   //;   for (my $i=0; $i<$num_inputs; $i++){
   //;     $str = $str." (~sel_x_local[${i}] | ~x[${i}]) &" if ! IsPowOfTwo($i+1);
   //;   }
   assign pp_all = ~( `$str` pp_pow2);
   // Select pp or pp_b based on sign
   assign pp = pp_all ^ sign_x; // invert if sign_x=1

   //;}


   
endmodule : `mname`
