/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Booth encoding for a multiplier.
 * 
 * Booth encoder produce the partial products for computing (x+xinc)*(y+yinc)
 * 
 * xinc yinc  result
 * 0    0     xy
 * 0    1     xy+x     (through y[-1]=yinc of booth encoding)
 * 1    0     xy+y     (through adding y as pp[0])
 * 1    1     xy+x+y+1 (through both methods and 1 is added to pp[2] to S[0])
 * 
 * Sign encoding:
 * --------------
 * SSSSSS.....S = -1 + ~S
 * 
 * S0 S0 S0 S0 S0 S0 S0 S0 S0 S0                              ~S0                      ~S0  S0  S0
 *                                                          0  -1
 * S1 S1 S1 S1 S1 S1 S1 S1                 =            ~S1               =          1 ~S1
 *                                                    0  -1
 * S2 S2 S2 S2 S2 S2                              ~S2                          1 ~S2
 *                                              0  -1
 * 
 * 
 * Final tree:
 * -----------                  __
 *                              S0 S0 S0 *  *  *  *  *  *  *  *  0  0
 *                              __
 *                           1  S1 *  *  *  *  *  *  *  *  0  S0
 *                        __
 *                     1  S2 *  *  *  *  *  *  *  *  0  S1
 *                  __
 *               1  S3 *  *  *  *  *  *  *  *  0  S2
 * 
 *   __
 * 1 Sn *  *  *  *  *  *  *  *  0  S(n-1)
 * 
 *                           Sn = 0 (because y is extended)    
 * 
 * 
 * Parameters:
 * * Width, BoothType
 * 
 * Exported Parameters:
 * * PPWidth, PPCount
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 04, 2011   shacham   init version - ported Sameh's original code to 
 *                          genesis + a little restructuring
 * Nov 09, 2011   shacham   Added basic functionality for booth 4
 * 
 * ****************************************************************************/


/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil); # For ceiling rounding math
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//;
//; # Interface parameter
//; my $useInc = parameter(Name=>'UseInc', Val=>'', List=>['YES', 'NO'],
//; 			   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc)");
//; $useInc = ($useInc =~ /YES/)?1:0;
//;
//; # module parameters
//; my $width = parameter(Name=>'Width', Val=>53, Min=>1, Step=>1,
//;                       Doc=>"Signal bit widths");
//; my $booth = parameter(Name=>'BoothType', Val=>2, Min=>1, Step=>1, Max=>4,
//;                       Doc=>"Booth type. (1 for no booth, 2 is default, 3 and 4 may sometimes be useful when Width is very large)");
//;
//; # Declare some local variables
//; my $extended_width = $width + 1 + $booth - ( $width % $booth);   # extended_width = width is odd?  width+2: width+3 
//; my $pp_count = ceil(($width + 1) / $booth);  # pp_count = width is odd? (width+1)/2 : (width+2)/2
//; $pp_count -=1 if ((!$useInc) && ($booth==1));
//; my $pp_width = ($booth==1)? $width+2 : $width+3*$booth;
//;
//; # Inform the world about the partial products properties
//; parameter(Name=>'PPWidth', Val=>$pp_width, Force=>1, 
//;           Doc=>"This is the calculated partial product width for Booth=$booth and Width=$width");
//; parameter(Name=>'PPCount', Val=>$pp_count+$useInc, Force=>1, 
//;           Doc=>"This is the calculated number of partial products for Booth=$booth and Width=$width. ".
//;                "Note that it includes a +1 to account for xinc and yinc");

module `mname`(
   //; if ($verif_mode =~ /ON/){
    input logic dumptolog,
   //; }
    input [`$width-1`:0] x, y,
   //; if ($useInc){
    input 		 xinc, yinc,
   //; }
    output [`$pp_width-1`:0] pp [0:`$pp_count+$useInc-1`] // `$pp_count`+ `$useInc` to account for xinc and yinc
		);
   
   //; if ($booth==1) {
   //;   if ($useInc){
   assign pp[0] = xinc ? {y, 2'b0} : `$pp_width`'b0; // add an extra y if xinc
   assign pp[1] = yinc ? {1'b0, x, xinc} : `$pp_width`'b0; // add an extra x if yinc and an extra 1 if xinc AND yinc
   //;     for (my $i=2; $i<=$pp_count; $i++){
   assign pp[`$i`] = y[`$i-2`] ? {2'b0, x}: `$pp_width`'b0;
   //;     }
   //;   }
   //;   else{ # i.e., no useInc...
   //;     for (my $i=0; $i<$pp_count; $i++){
   assign pp[`$i`] = y[`$i`] ?  {2'b0, x} : `$pp_width`'b0;
   //;     }   
   //;   }
   //;
   //; } # End of "if ($booth==1)..." 
   //; elsif ($booth>=2) {

   logic [`$extended_width`-1:0] extended_y;
   // yinc added at position y[-1] will increase the partial products by X thereby producing xy+x = x(y+1)
   assign extended_y = {{(`$booth - ( $width % $booth) `) {1'b0} },y,yinc};  //sign extension guarantees positive last partial product
   
   logic [`$width+$booth-1`:0] 	 initial_pp [0:`$pp_count-1`] ;
   logic [`$pp_count-1`:0] 	 S;  // S[`$pp_count-1`] is guaranteed to be 0 because of the sign extension of 0 in extended b


   
   //;   # If booth==3 we need to prepare a 3*x and ~(3*x) products
   //;   if ($booth>=3) {
   // Prepare the 3*X 
   logic [`$width+1`:0] 	 x3;
   //;   my $HM3_obj = generate('HardMultiple3', 'HM3', Width=>$width);
   `$HM3_obj->instantiate` (
			    //; if ($verif_mode =~ /ON/){
			    .dumptolog(dumptolog),
			    //; }
			    .x(x), .x3(x3));
   //;   }
   
   //;   if ($booth>=4) {
   // Prepare the 5*X 
   logic [`$width+2`:0] 	 x5;
   //;   my $HM5_obj = generate('HardMultiple5', 'HM5', Width=>$width);
   `$HM5_obj->instantiate` (
			    //; if ($verif_mode =~ /ON/){
			    .dumptolog(dumptolog),
			    //; }
			    .x(x), .x5(x5));

   // Prepare the 7*X 
   logic [`$width+2`:0] 	 x7;
   //;   my $HM7_obj = generate('HardMultiple7', 'HM7', Width=>$width);
   `$HM7_obj->instantiate` (
			    //; if ($verif_mode =~ /ON/){
			    .dumptolog(dumptolog),
			    //; }
			    .x(x), .x7(x7));
   //;   }

   
   // Instantiate the booth `$booth` encoders
   //;   for(my $i=0; $i < $pp_count; $i++){
   //;     my $BoothEnc_obj = generate('BoothEnc', "BoothEnc_u$i", BoothType=>$booth, Width=>$width);
   `$BoothEnc_obj->instantiate`
     (.x(x), 
      //;   if ($booth>=3) {
      .x3(x3),
      //;   }
      //;   if ($booth>=4) {
      .x5(x5), .x7(x7),
      //;   }			     
      .y(extended_y[`$booth*($i+1)`:`$booth*$i`]) , .pp(initial_pp[`$i`]), .S(S[`$i`]));
   
   //;   } # End of "for(my $i=0..."

   
   // Finally, append the sign extenssions to the partial products
   assign pp[0] = xinc ? {{(`$booth`){1'b0}}, y, {(2*`$booth`){1'b0}}} : 0;
   assign pp[1] = {initial_pp[0][`$width+$booth-1`], {(`$booth`){S[0]}}, initial_pp[0][`$width+$booth-2`:0], {(`$booth`){1'b0}}};
   assign pp[2] = {1'b0, {(`$booth-1`){1'b1}}, initial_pp[1], {(`$booth-2`){1'b0}}, S[0] & xinc & yinc , S[0] ^ (xinc & yinc) };  //correction 1 is added for (x+1)(y+1) 
   //;   for(my $i=3; $i < $pp_count+1; $i++) {
   assign pp[`$i`] = {1'b0, {(`$booth-1`){1'b1}}, initial_pp[`$i-1`], {(`$booth-1`){1'b0}},S[`$i-2`]};
   //;   }
   //; } # End of "elsif ($booth==2 || $booth==3)..."

endmodule: `mname`

