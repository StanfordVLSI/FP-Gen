/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/ClosePathSub.vp#1 $
 ** $DateTime: 2012/02/08 11:27:28 $
 ** $Change: 10078 $
 ** $Author: jbrunhav $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * Close Path Subtractor
 * 
 * 
 * Parameters:
 * * Width
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Oct 13, 2011   sameh   init version - ported Sameh's original code to 
 *                          genesis
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(ceil log); # For ceiling rounding and log math
//; sub CeilOfLog2{ return ceil(log(@_)/log(2)); }
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the Fraction for the multiplier (default is IEEE Double, 52 bit)  !FUNCTIONAL!");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the exponent for the multiplier (default is IEEE Double, 11 bit)  !FUNCTIONAL!");
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>3, List=>[ 0,1,2,3,4,5,6,7 ] ,
//;                       Doc=>"Pipeline depth !FUNCTIONAL!");
//; my $useInc = parameter(Name=>'useInc', Val=>'YES', List=>['YES', 'NO'],
//; 			   Doc=>"Inputs A has an increment signal");
//;
//; # And some local variables
//; my $manA_width = $frac_width + 1;
//; my $manB_width = 2 * $manA_width;
//; my $ExtendedExp_width = $exp_width + 2;
//; my $shift_width = CeilOfLog2($manB_width+1) + 1;
module `mname`(
 //; if ($verif_mode =~ /ON/){
  input logic dumptolog,
 //; }
  input logic [`$manA_width-1`:0] ManA_in, 
  //; if ($useInc =~ /YES/){
  input logic IncA_in,
  //; }
  input logic [`$ExtendedExp_width-1`:0] ExpA_in, ExpB_in, 
  input logic SignA_in, SignB_in,
  input logic [`$manB_width-1`:0] ManB_in,
  input logic  clk , reset, valid_in, stall,
  output logic [`$manA_width-1`:0] ManDiff_out, 
  output logic Guard_out, Sticky_out, LZA_wrong_out, SignDiff_out, ZeroDiff_out,
  output logic [`$exp_width-1`:0] ExpDiff_out, 
  output logic [`$ExtendedExp_width-1`:0] Expbase_pp0, Expbase_pp1,
  output logic Expbase_ci, 
  output logic  valid_out
              );


  //; if (! ($useInc =~ /YES/) ){
  logic IncA_in;
  assign IncA_in = 0;
  //; }

  logic [`$manA_width-1`:0] ManA;
  logic [`$manB_width-1`:0] ManB;
  logic [`$ExtendedExp_width-1`:0] ExpA, ExpB; 
  logic IncA, SignA, SignB, valid_middle;
  logic [`$manA_width-1`:0] ManDiff;
  logic [`$exp_width-1`:0] ExpDiff;
  logic Guard, Sticky, LZA_wrong, SignDiff, ZeroDiff;
  logic [`$ExtendedExp_width-1`:0] LShiftAmtWide;

//;   my $pipe_in = generate(  'Pinned_pipeline',  'pipe_in',  
//;                             Width=> $manA_width + $manB_width + 2*$ExtendedExp_width + 3,
//;                             PipelineDepth => $pipeline_depth-1);
  `$pipe_in ->instantiate()` ( .in({ManA_in, IncA_in, ExpA_in, SignA_in, ManB_in, ExpB_in, SignB_in}) ,
                               .valid_in(valid_in), .clk(clk) , .stall(stall), .reset(reset), 
                               .out({ManA, IncA, ExpA, SignA, ManB, ExpB, SignB}),
                               .valid_out(valid_middle) );

//;   my $pipe_out = generate(  'FF_pipeline',  'pipe_out',
//;                              Width=> $manA_width + $exp_width + 5,
//;                              PipelineDepth => ($pipeline_depth>0?1:0), Retime=>'YES');
  `$pipe_out->instantiate()` ( .in({ManDiff, ExpDiff, Guard, Sticky, LZA_wrong, SignDiff, ZeroDiff}) ,
                                .valid_in(valid_middle), .clk(clk) , .stall(stall), .reset(reset), 
                                .out({ManDiff_out, ExpDiff_out, Guard_out, Sticky_out, LZA_wrong_out, SignDiff_out, ZeroDiff_out}),
                                .valid_out(valid_out) ); 

  logic [`$manB_width-1`:0] manA_wide;
  logic [`$exp_width-1`:0] ExpDiff_pp0, ExpDiff_pp1, ExpDiff0, ExpDiff1, ExpDiff2;
  logic [`$manB_width+1`:0] op1, op2, diff, max_shift_mask;
  logic [`$manB_width+2`:0] shiftedDiff;
  logic ExpB_gt_ExpA_1, ExpB_gt_ExpA_2, ExpA_gt_ExpB_1, ExpA_gt_ExpB_2, mostSticky, a_gt_b, co_dummy0, co_dummy1, co_dummy2;
  logic [`$shift_width-1`:0] LshiftAmt;
  logic [(1<<`$shift_width`)-1 : 0] max_shift_dec;



  assign manA_wide = {1'b0,ManA,{(`$manB_width-$manA_width-1`){IncA}}}; //pad to the right with zeros for the mantissa

  assign ExpA_gt_ExpB_1 = ExpA[1] ^ ExpB[1]?  ~ExpA[0] &  ExpB[0] : ExpA[0] &  ~ExpB[0];
  assign ExpA_gt_ExpB_2 = (ExpA[0] ~^ ExpB[0])  & (ExpA[2] ^ ExpB[2]?  ~ExpA[1] &  ExpB[1] : ExpA[1] &  ~ExpB[1]);
  assign ExpB_gt_ExpA_1 = ExpA[1] ^ ExpB[1]?   ExpA[0] & ~ExpB[0] :~ExpA[0] &   ExpB[0];
  assign ExpB_gt_ExpA_2 = (ExpA[0] ~^ ExpB[0]) & (ExpA[2] ^ ExpB[2]?   ExpA[1] & ~ExpB[1] :~ExpA[1] &   ExpB[1]);



  assign op1 = ExpB_gt_ExpA_2? {2'b0 , manA_wide}
                             : ExpB_gt_ExpA_1? {1'b0 ,manA_wide,IncA} : {manA_wide,IncA,IncA};
  assign op2 = ExpA_gt_ExpB_2? {2'b0 , ManB}
                             : ExpA_gt_ExpB_1? {1'b0 , ManB,1'b0} : {ManB,2'b0};

  assign Expbase_pp0 = (ExpA_gt_ExpB_1 | ExpA_gt_ExpB_2)? ExpA: ExpB;
  assign Expbase_pp1 = ~LShiftAmtWide;
  assign Expbase_ci  = op2[`$manB_width+1`];
 
  //Subtraction + LZA
  
  DW_decode_en #(`$shift_width`) U1 ( .en(~|Expbase_pp0[`$ExtendedExp_width-2`:`$shift_width`])    // Disable if the exponent is big enough
                                 , .a(Expbase_pp0[`$shift_width-1`:0])
                                 , .b(max_shift_dec) );

  //assign max_shift_mask= {max_shift_dec[manB_width+1:2],max_shift_dec[1] | max_shift_dec[0]};
  assign max_shift_mask[`$manB_width+1`] = max_shift_dec[1] | max_shift_dec[0]; //The mask has one at Expbase_pp0 - 1 position
  
//; for (my $i=$manB_width ; $i>=0 ; $i--)
//; {
  assign max_shift_mask[`$i`] = max_shift_dec[`$manB_width-$i+2`]; 
//; }


//; my $Abs_diff_obj = generate('AbsoluteDifference', 'manDiff', 
//;                                                 , Width =>$manB_width+2
//;                                                 , LZA_enable => 'YES'
//;                                                 , useInc => ($useInc =~ /YES/)?1:0 );


  `$Abs_diff_obj->instantiate()` (.a(op1),
  //; if ($useInc =~ /YES/) {
                                  .ainc(IncA),
  //; }
                                  .b(op2), .rsticky_b(1'b0), .absdiff(diff), .LZA_override_mask(max_shift_mask), .a_gt_b(a_gt_b),.LZA_count(LshiftAmt), .dumptolog(dumptolog)); // The shift amount

  //normalization

  assign shiftedDiff = {1'b0,diff} << LshiftAmt;
  assign LZA_wrong = Expbase_ci? shiftedDiff[`$manB_width+2`] : shiftedDiff[`$manB_width+1`]; 
  assign mostSticky = (| shiftedDiff[`$manB_width-$manA_width-1`:0]);
  assign {ManDiff, Guard, Sticky} = shiftedDiff[`$manB_width+2`] ? 
        {shiftedDiff[`$manB_width+2`:`$manB_width-$manA_width+2`],
         mostSticky | shiftedDiff[`$manB_width-$manA_width+1`] | shiftedDiff[`$manB_width-$manA_width`]}
        : shiftedDiff[`$manB_width+1`] ?
                          {shiftedDiff[`$manB_width+1`:`$manB_width-$manA_width+1`],mostSticky | shiftedDiff[`$manB_width-$manA_width`]}
                         :{shiftedDiff[`$manB_width`:`$manB_width-$manA_width`],mostSticky};

  assign ZeroDiff= (diff==0);


  //calculate Expbase_pp0 - LShiftAmt + (0 | 1 | 2)
  assign LShiftAmtWide = LshiftAmt;
  assign ExpDiff_pp0 = {Expbase_pp0[`$exp_width-1`:1] ^ Expbase_pp1[`$exp_width-1`:1], Expbase_pp0[0] ^ ~Expbase_pp1[0]};
  assign ExpDiff_pp1 = {Expbase_pp0[`$exp_width-2`:1] & Expbase_pp1[`$exp_width-2`:1], Expbase_pp0[0] | Expbase_pp1[0],1'b0};


//; my $CompoundAdder_obj = generate('CompoundAdder', 'CA', 
//;                                                 , Width =>$exp_width);

  `$CompoundAdder_obj->instantiate()` (
            //; if ($verif_mode =~ /ON/){
                                   .dumptolog(dumptolog),
            //; }
                                   .a(ExpDiff_pp0), .b(ExpDiff_pp1),
                                   .sum0(ExpDiff0), .co0(co_dummy0),
                                   .sum1(ExpDiff1), .co1(co_dummy1));
  assign ExpDiff2 = ExpDiff_pp0 + ExpDiff_pp1 + 2;
  
  assign ExpDiff = ZeroDiff ? 0 : shiftedDiff[`$manB_width+2`]? ExpDiff2 : shiftedDiff[`$manB_width+1`]? ExpDiff1 :ExpDiff0; // handle total cancelation case
  assign SignDiff = ZeroDiff ? 0 : a_gt_b ^ SignB;

//; if ($verif_mode =~ /ON/){
// synopsys translate_off
always @(posedge dumptolog)
begin
    $display ("`$self->get_instance_path()`: ManA=%b",ManA);
    $display ("`$self->get_instance_path()`: op1=%b op2=%b ",op1, op2);
    $display ("`$self->get_instance_path()`: ExpB_gt_ExpA_1=%b, ExpB_gt_ExpA_2=%b, ExpA_gt_ExpB_1=%b, ExpA_gt_ExpB_2=%b",ExpB_gt_ExpA_1, ExpB_gt_ExpA_2, ExpA_gt_ExpB_1, ExpA_gt_ExpB_2);
    $display ("`$self->get_instance_path()`: ExpDiff=%h ManDiff=%h Guard=%b Sticky=%b SignDiff=%b",ExpDiff, ManDiff, Guard, Sticky, SignDiff);
    $display ("`$self->get_instance_path()`: Expbase_pp0=%h, LShiftAmtWide=%d ExpDiff0=%h ExpDiff1=%h",Expbase_pp0, LShiftAmtWide, ExpDiff0, ExpDiff1);
    $display ("`$self->get_instance_path()`: diff=%h max_shift_mask=%h LshiftAmt=%d shiftedDiff=%h LZA_wrong=%b",diff, max_shift_mask, LshiftAmt, shiftedDiff, LZA_wrong);
    $display ("`$self->get_instance_path()`: Expbase_pp0=%h max_shift_dec=%h SignA=%b SignB=%b", Expbase_pp0,max_shift_dec,  SignA, SignB);
end
// synopsys translate_on
//; }

endmodule

