/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/FP-Gen/rtl/ZM_Column.vp#1 $
 ** $DateTime: 2011/11/07 22:38:49 $
 ** $Change: 9561 $
 ** $Author: artem $
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * This is a ZM_Column that process a vertical slice in multiplication tree 
 * using a ZM tree architecture
 *
 * Parameters:
 * * ColumnHight, ColumnPosition, MinRow, BoothType, OneLessCarryIn, LayoutShape
 * 
 *
 * Inputs:
 * * Given that N=ColumnHight
 * * [N-1:0] pp                 
 * * [(N-3)-1:0] ci   (Note: if OneLessCarryIn then we have one less ci)
 *  
 * Outputs:
 * * sum
 * * carry
 * * [(N-3)-1:0] co
 *
 * Change bar:
 * -----------
 * Date           Author    Description
 * Nov 07, 2011   Artem     initial version
 * 
 * ****************************************************************************/

/* Zuras-McAllister "Balanced Delay Trees and Combinatorial Division in VLSI" ISSJ '86


n   array     depth
-------------------
2   -           0
3   3           1      3
4   4           2      4
5   5           3      5
6   3,3         3      3,3
7   4,3         4      3,4
8   4,4         4      4,4
9   3,3,3       5  **  4,5
10  3,3,4       5  **  5,5 
11  3,3,5       5      3,3,5
12  4,4,4       6  **  6,6
13  4,4,5       6      4,4,5
14  4,4,6       6      4,4,6
15  3,3,5,4     7  **  4,4,7
16  3,3,5,5     7  **  4,5,7
17  3,3,5,6     7  **  5,5,7
18  3,3,5,7     7      3,3,5,7
19  4,4,6,5     8  **  6,6,7
20  4,4,6,6     8      4,4,6,6
21  4,4,6,7     8      4,4,6,7
22  4,4,6,8     8      4,4,6,8
23  3,3,5,7,5   9  **  4,4,6,9
24  3,3,5,7,6   9  **  4,4,7,9
25  3,3,5,7,7   9  **  4,5,7,9
26  3,3,5,7,8   9  **  5,5,7,7
27  3,3,5,7,9   9      3,3,5,7,9
28  4,4,6,8,6  10  **  6,6,7,7

detect n at which the number of arrays increases:

n = 1 + (4+4+6+8+10+12+.....+d-1) = 3 + Sigma ( x -> 1:(d-1)/2 , 2x) = 3 + 0.25 (d-1)*(d+1) 
d^2 - 4n + 11 = 0

d = sqrt(4*n-11) = (4*n-11)**0.5
array_count = (d+1)/2 = ((4*n-11)**0.5+1)/2

now we need to detect if we are using even or odd arrays by comparing n to the n_odd limit

n_odd = 3+3+5+7+...+2*array_count-1 = 2 + Sigma ( x -> 1:array_count , 2x-1) = 2 + array_count^2

n_odd : 6, 11, 18, 27


*/




/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//; use POSIX qw(floor ceil); # For floor and ceiling rounding math 
//;
//; # get some values from the top
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level
//; my $synth_mode = $self->get_top_param('SYNTH_MODE'); # Reads this parameter from the top level
//;
//; # module parameters

//; my $col_ht = parameter(Name=>'ColumnHight', Val=>2, Min=>2, Step=>1,
//;                          Doc=>"Number of partial products in relevant column to sum");
//; my $col = parameter(Name=>'ColumnPosition', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The column number");
//; my $min_row = parameter(Name=>'MinRow', Val=>0, Min=>0, Step=>1,
//;                          Doc=>"The starting row position");
//; my $booth = parameter(Name=>'BoothType', Val=>1, Min=>1, Max=>3, Step=>1,
//;                       Doc=>"What booth was used to create the partial products? ".
//;                            "(This determines the slope of the partial products ".
//;                            "paralleloid)");
//; my $one_less_ci = parameter(Name=>'OneLessCarryIn', Val=>0, Min=>0, Step=>1, Max=>1,
//;                      Doc=>"Is there one less carry in for this column?");
//; my $layout_shape = parameter(Name=>'LayoutShape',Val=>'Square', List=>['Square','Parallelogram'],
//;                              Doc=>"Hints for layout positioning (Supported layouts: Square, Parallelogram)");
//;
//; my $ci_w = ($one_less_ci) ? $col_ht-4:$col_ht-3;
//; $ci_w = 0 if ($ci_w < 0); # can't have negative width
//; my $co_w = $col_ht-3;
//; $co_w = 0 if ($co_w < 0); # can't have negative width
//;
//; # print STDERR "DEBUG: hight=$col_ht, col=$col, min_row=$min_row, booth=$booth, ci_w=$ci_w, co_w=$co_w \n";

module `mname()` (
    input logic [`$col_ht-1`:0] pp,
//; if($ci_w){
    input logic  [`$ci_w-1`:0] ci,
//; }
//;if($co_w){
    output logic [`$co_w-1`:0] co,
//;}
    output logic sum, carry
   );

   

   //;
   //;my $array_count = ($col_ht>2) ? floor((sqrt(4*$col_ht-11)+1)/2) : 0; 
   //;$array_count = 1 if ($col_ht==5 || $col_ht==2);
   // array_count = `$array_count`;
   //;
   //;  my $pp_index = 0;
   //;  my $ci_index = 0;
   //;  my $co_index = 0;
   //;  my $array_csa_prev = 0; 
   //;  for (my $array=0; $array < $array_count; $array++){
   //;	     my $array_length = ( ($col_ht > 2 + $array_count*$array_count)? ($array==0? 4 : $array==$array_count-1? $col_ht - $array*($array+1)- 2 : 2+2*$array) : ($array==0? 3 : $array==$array_count-1? $col_ht - $array*$array- 2 : 1+2*$array) );
   //;       $array_length = 5 if ($col_ht==5);
   //;       my $array_csa = $array_length - 2;
   //;       $array_csa_prev = $array_csa;
   // array = `$array` , array_length = `$array_length`;

   //;	     for(my $nodes = 0; $nodes < $array_csa; $nodes++ ){
   //;           if($array_count==1 && $nodes==($array_csa-1) && $one_less_ci && (($array_csa > 1) || ($col_ht==2))) {
   //;               my $CSA_obj = generate('HA', "csa_${array}_${nodes}");
      logic [1:0] pp_`$array`_`$nodes`;
   //;               if($col_ht==2) {
      assign pp_`$array`_`$nodes`= pp[`$pp_index+1`:`$pp_index`];
   //;		         $pp_index+=2;
 
   //;               } else {
      assign pp_`$array`_`$nodes`= {pp_`$array`_`$nodes-1`_s,pp[`$pp_index`]};
   //;		         $pp_index++;
   //;               } #if($col_ht==2)
      `$CSA_obj->instantiate()` ( .a(pp_`$array`_`$nodes`[0]), .b(pp_`$array`_`$nodes`[1]),
                                    .s(sum), .co(carry) );
   //;           } else {	   
  	    
   

   //;               my $CSA_obj = generate('CSA', "csa_${array}_${nodes}");
      logic [2:0] pp_`$array`_`$nodes`;
   //;		     if($nodes == 0){
      assign pp_`$array`_`$nodes`= pp[`$pp_index+2`:`$pp_index`];
   //;		         $pp_index+=3;
   //;		     } else{
      assign pp_`$array`_`$nodes`= {pp[`$pp_index`],pp_`$array`_`$nodes-1`_s,ci[`$ci_index`]};
   //;		         $pp_index++;
   //;		         $ci_index++;
   //;		     }
      logic pp_`$array`_`$nodes`_s;

      `$CSA_obj->instantiate()` ( .a(pp_`$array`_`$nodes`[0]), .b(pp_`$array`_`$nodes`[1]), .ci(pp_`$array`_`$nodes`[2]),
   //;               if( $array_count == 1 && $nodes == ($array_csa-1)) {
                                  .s(sum), .co(carry) );
   //;               } else {
                                  .s(pp_`$array`_`$nodes`_s), .co(co[`$co_index`]) );
   //;               } #if( $array_count == 1 && $nodes
   //; 	             $co_index++;
   //;           } #if($array_count==1 && $nodes==($array_csa-1) && $one_less_ci )
   //;       }# for(my $nodes = 0; $nodes




   //;	     if($array>0) {
   //Merge branche `$array-1` and `$array`
   //;       	    my $CSA_obj = generate('CSA', "csa_merge_${array}");
      logic [2:0] pp_merge_`$array-1`;
      assign pp_merge_`$array-1`[2] = pp_`$array`_`$array_csa-1`_s;
   //;           if($array==1) {
      assign pp_merge_`$array-1`[0] = pp_`$array-1`_`$array_csa_prev-1`_s;
   //;           } else {
      assign pp_merge_`$array-1`[0] = pp_merge1_`$array-2`_s;
   //;           } #if($array==1) {
      assign pp_merge_`$array-1`[1] = ci[`$ci_index`];
      logic pp_merge_`$array-1`_s;

      `$CSA_obj->instantiate()` ( .a(pp_merge_`$array-1`[0]), .b(pp_merge_`$array-1`[1]), .ci(pp_merge_`$array-1`[2]),
                                  .s(pp_merge_`$array-1`_s), .co(co[`$co_index`]) );
   //;              $ci_index++;
   //;              $co_index++;

      logic [2:0] pp_merge1_`$array-1`;
      assign pp_merge1_`$array-1`[2] = pp_merge_`$array-1`_s;
      assign pp_merge1_`$array-1`[0] = ci[`$ci_index`];
   //;                  $ci_index++;
   //;	                if($array==($array_count-1) && $one_less_ci){
   //;       	             my $CSA_obj = generate('HA', "csa_merge1_${array}");
      `$CSA_obj->instantiate()` ( .a(pp_merge_`$array-1`[0]), .b(pp_merge_`$array-1`[2]),
                                  .s(sum), .co(carry) );
   //;                  }
   //;                  else {
   //;       	             my $CSA_obj = generate('CSA', "csa_merge1_${array}");
      assign pp_merge1_`$array-1`[1] = ci[`$ci_index`];
   //;                       $ci_index++;
   //;                       if($array==($array_count-1)) {
      `$CSA_obj->instantiate()` ( .a(pp_merge_`$array-1`[0]), .b(pp_merge_`$array-1`[1]), .ci(pp_merge_`$array-1`[2]),
                                  .s(sum), .co(carry) );
   //;                       }
   //;                       else {
      `$CSA_obj->instantiate()` ( .a(pp_merge_`$array-1`[0]), .b(pp_merge_`$array-1`[1]), .ci(pp_merge_`$array-1`[2]),
                                  .s(pp_merge1_`$array-1`_s), .co(co[`$co_index`]) );
   //;                             $co_index++;
   //;                       }# if($array==($array_count-1) 

   //;                  }#if($array==($array_count-1) && $one_less_ci
   
   
   //;	     }#if($array>0)

   //;       $array_csa_prev = $array_csa;
   //;}#for (my $array=0; $array 



endmodule


