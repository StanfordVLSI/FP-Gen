/*************************************************************************
 ** From Perforce:
 **
 ** $Id$
 ** $DateTime$
 ** $Change$
 ** $Author$
 *************************************************************************/

/* *****************************************************************************
 * Description:
 * ------------
 * Booth THREE, single cell encoding for a multiplier. Produce one bit of one
 * partial product.
 * 
 * 
 * Y[3:0]     y_edge_vec    out  =  pp   +   S
 * 	                  
 * 0 0 0 0    -000          +0      100000   +0      
 * 0 0 0 1    -001          +X      (100X)   +0
 * 0 0 1 0    -011          +X      (100X)   +0
 * 0 0 1 1    -010          +2X     (10X0)   +0
 * 0 1 0 0    -110          +2X     100000   +0      
 * 0 1 0 1    -111          +3X     (1X3)    +0
 * 0 1 1 0    -101          +3X     (1X3)    +0
 * 0 1 1 1    -100          +4X     (1X00)   +0
 * 1 0 0 0    -100          -4X     (0~X11)  +1      
 * 1 0 0 1    -101          -3X     (0~X3)   +1
 * 1 0 1 0    -111          -3X     (0~X3)   +1
 * 1 0 1 1    -110          -2X     (01~X1)  +1
 * 1 1 0 0    -010          -2X     (01~X1)  +1
 * 1 1 0 1    -011          -X      (011~X)  +1
 * 1 1 1 0    -001          -X      (011~X)  +1
 * 1 1 1 1    -000          -0      011111   +1
 * 
 * 
 * Parameters:
 * -----------
 * 
 * 
 * Change bar:
 * -----------
 * Date           Author    Description
 * Nov 05, 2011   shacham   init version - 
 *                          
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; # Perl Libraries
//;
//;
//; my $verif_mode = $self->get_top_param('VERIF_MODE'); # Reads this parameter from the top level




module `mname` (
    input logic 		sel_x, sel_x2, sel_x3, sel_x4,
    input logic [2:0] 		x,
    input logic 		x3, 
//    input logic [2:0] 		y_edge_vector,		// y_edge_vector[i] = y[i]==y[i+1]
    input logic 		y_msb,                 	// y[3]
    output logic 		pp               	// single bit of the relevant pp
		);
   
   /* TO ME:
    * X3 and X3_b are late signals. Therefore, rather than muxing {0,x,2x,3x,4x,4x_b,3x_b,2x_b,x_b} 
    * we will first mux x vs. x_b (assign it to x_out), then we'll mux {0,x_out, 2x_out, 4x_out} (assign 
    * it to pp0124) and then mux {pp0124, x3, x3_b}. Capiche?
    * */

/*******************************************************************************
 * Simpler implementation. However it does not give us control on placing of
 * each booth3cell.
 * *****************************************************************************
   // Mux x and x_b based on sign
   logic [$width-1:0] 	x_out;
   assign S = y_msb;
   assign x_out = S ? x_b: x;

   logic [$width+2:0]   pp0124;
   

    always_comb
     begin
	// Mux 0, x_out, 2x_out, 4x_out based on the edge vector
	unique case (y_edge_vector)
	  // 3'b000:  	pp0124 = {~S,{($width+2){S}}};	// yedge = 000 ==> 0 
  	  3'b001,3'b011:pp0124 = {~S,S,S,x_out};		// yedge = 0X1 ==> +/-X     
  	  3'b010,3'b110:pp0124 = {~S,S,x_out,S};		// yedge = X10 ==> +/-2X 
  	  3'b100:	pp0124 = {~S,x_out,S,S};		// yedge = 100 ==> +/-4X
	  default: pp0124 = {~S,{($width+2){S}}};
        endcase // case (y_edge_vector)
  
   
	// Mux pp0124, 3x, 3x_b based on the edge vector and sign
	unique case ({(y_edge_vector[2] & y_edge_vector[0]),S})
	  2'b10:  pp = {~S,x3};                       
	  2'b11:  pp = {~S,x3_b};
	  //2'b00, 2'b01:  pp = pp0124;
	  default: pp = pp0124;
	endcase
     end
 *******************************************************************************/ 

   logic 			pp0124;
   logic 			pp01234;
   
   assign S = y_msb;
   
   // Mux 0, x, 2x, 4x based on the edge vector
   assign pp0124 = (sel_x & x[2]) | (sel_x2 & x[1]) | (sel_x4 & x[0]);
 
   // Mux pp0124, 3x based on the edge vector
   assign pp01234 = (sel_x3 & x3) | pp0124;

   // Select pp or pp_b based on sign
   assign pp = pp01234 ^ S; // invert if S=1

   
endmodule : `mname`
