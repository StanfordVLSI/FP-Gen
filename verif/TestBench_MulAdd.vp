/* *****************************************************************************
 * Description:
 * -----------
 * TestBench for FMA
 * 
 * Runtime Arguments 
 * -----------------
 * (Via the "make run RUN=+<runtime_flag[=value]>" notation)
 * * Wave, Seed, NumTrans
 * 
 * Parameters:
 * -----------
 * * FractionWidth, ExponentWidth, Architecture, TestDenormals, UseInc
 * * NumTrans, Seed
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Oct 05, 2011  shacham   init version - test generator for FP Mult-Acc
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the signal for the multiplier (default is IEEE Double, 52 bit)");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the signal for the multiplier (default is IEEE Double, 11 bit)");
//; my $arch = parameter(Name=>'Architecture', Val=>'Cascade', List=>['Cascade', 'Fused'],
//; 			 Doc=>"Which architecture is tested? Cascaded multiply accumulate ".
//; 			      "or Fused? (Pick:Cascade/Fused)");
//; my $vector_file = parameter(Name=>'TestVectorFile', Val=>'',
//;                             Doc=>"Name of the input testvector file");
//; my $enable_forwarding = parameter(Name=>'EnableForwarding', Val=>'YES', List=>['YES', 'NO'],
//; 	 		   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc) !FUNCTIONAL!");
//; my $test_denormals = parameter(Name=>'TestDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO)");
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>1, Min=>0 , Step=>1,
//;                       Doc=>"Pipeline depth !FUNCTIONAL!");
//; my $mul_pipeline_depth = parameter(Name=>'MulPipelineDepth', Val=>4,
//;                       Doc=>"Multiplier Part Pipeline depth");
//; my $useInc = parameter(Name=>'UseInc', Val=>'YES', List=>['YES', 'NO'],
//; 			   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc)");
//; my $num_trans = parameter(Name=>'NumTrans',Val=>10, Min=>1, Step=>1,
//;                           Doc=>"Number of test transactions to run ".
//;                                "(can be overriden at runtime using the '+NumTrans=value' command line notation)");
//; my $seed = parameter(Name=>'Seed',Val=>12345, Min=>0, Step=>1,
//;                      Doc=>"Seed for random values".
//;                      "(can AND SHOULD be overriden at runtime using the '+Seed=value' command line notation)");
//; my $forward_cycle = $pipeline_depth-1;
//; my $forward_cycle_a = parameter (Name=>'ForwardCycA', Val=>$forward_cycle,  Max=>$pipeline_depth,
//;                                    Step=>1, Doc=>"The cycles that forwarding signal comes from" );
//; my $forward_cycle_b = parameter (Name=>'ForwardCycB', Val=>$forward_cycle,  Max=>$pipeline_depth,
//;                                    Step=>1, Doc=>"The cycles that forwarding signal comes from" );
//; my $forward_cycle_c = parameter (Name=>'ForwardCycC', Val=>$forward_cycle,  Max=>$pipeline_depth,
//;                                    Step=>1, Doc=>"The cycles that forwarding signal comes from" );
//;                                 
//; my $product_width = 2 * $frac_width + 2; # (leading one + frac_w) *2;
//; my $fp_width = $frac_width + $exp_width + 1;
//;
program automatic `mname` (
			   output logic 			       dumptolog,
			   // signals to drive the design
			   output logic [`$exp_width + $frac_width`:0] a, b, c,
			   output logic [2:0] 			       rnd,
			   //; if ($enable_forwarding eq 'YES'){
			   output logic 			       forward_a, forward_b, 
			   output logic [`$mul_pipeline_depth`:0]      forward_c,
			   //; }			
			   //; if ($pipeline_depth>0){
			   output logic 			       clk, reset, stall_pipeline, SI, SCAN_ENABLE, test_mode, valid_in, stall_in,
			   input logic 				       SO,
			   //; } else {
			   output logic 			       clk, reset,
			   //; }
			   // results from the design
			   input logic [`$exp_width + $frac_width`:0]  z,
			   input logic [7:0] 			       status ,
			   input logic 				       valid_out, stall_request
			   );

   // Local variables and handles for controlling the simulation
   int 								       seed=`$seed`;
   int 								       wave=0;
   int 								       wave_delay=0;
   int 								       num_trans = `$num_trans`;
   int 								       dummy;
   string 							       vector_file = "`$vector_file`";
   


   // Local variables and macros for controlling the input file and local memory
   parameter MEM_SIZE = 1000000;
   parameter MEM_WIDTH = 4+`$fp_width*4`+4+4+4+4+4;

   // Signals for the input testvector verification
   logic [MEM_WIDTH-1:0] 					       Memory [0:MEM_SIZE-1];  // Space for input file
   logic [MEM_WIDTH-1:0] 					       Temp, Temp_q[$], r_Temp;  // Verilog doesn't allow direct access to a
   // bit field of an array
   logic [`$exp_width + $frac_width`:0] 			       expectZ, z2;
   // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
   logic 							       FX, FO, FU, FV, FZ,expectNaN;
   int 								       loc;

   logic 							       zinc=0, ainc=0, binc=0, cinc=0;
   
   
   // Singals for pipeline output
   logic [`$exp_width + $frac_width`:0] 			       r_a, r_b, r_c, expected, r_expected, a_q[$], b_q[$], c_q[$], expected_q[$];
   logic [2:0] 							       r_rnd;

   logic 							       resultIsZero, expectIsZero;


   assign stall_in = 1'b0 ;
   
   
   // FP transaction handles
   //; my $TransGenA_obj = generate('FPTransaction','TransGenA',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width,
   //; 				    Architecture=>$arch,
   //;                              TestDenormals=>$test_denormals);
   `$TransGenA_obj->instantiate`;
   //; my $TransGenB_obj = generate('FPTransaction','TransGenB',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>$arch,
   //;                              TestDenormals=>$test_denormals);
   `$TransGenB_obj->instantiate`;
   //; my $TransGenC_obj = generate('FPTransaction','TransGenC',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>'Fused', 
   //;                              TestDenormals=>$test_denormals);
   `$TransGenC_obj->instantiate`;

   // one more handle for the observed output
   //; my $TransRes_obj = generate('FPTransaction','TransRes',
   //;				    Random=>'NO',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>$arch,   
   //;                              TestDenormals=>$test_denormals);
   `$TransRes_obj->instantiate`;

   
   // Reference model
   //; my $GoldRef_obj = generate('GoldFMA', 'GoldRef', 
   //;                              FPTransA_Ptr=>$TransGenA_obj, 
   //;                              FPTransB_Ptr=>$TransGenB_obj,
   //;                              FPTransC_Ptr=>$TransGenC_obj,
   //;                              FPTransRes_Ptr=>$TransRes_obj,
   //;                              TestDenormals=>$test_denormals);
   `$GoldRef_obj->instantiate`;


   //; my $forward_A;
   //; my $forward_B;
   //; my $forward_C;
   //; if ($enable_forwarding eq 'YES'){
   // Random model for forwarding signal
   //; $forward_A = generate('forward', 'ForwardA', Width=>1);
   `$forward_A->instantiate()`;
   //; $forward_B = generate('forward', 'ForwardB', Width=>1);
   `$forward_B->instantiate()`; 
   //; $forward_C = generate('forward', 'ForwardC', Width=>$mul_pipeline_depth+1);
   `$forward_C->instantiate()`;
   logic							       forward_a_q[$], forward_b_q[$];
   logic  [`$mul_pipeline_depth`:0]                                    forward_c_q[$];
   
   //; }
   
   initial forever
     begin
	clk=1;	//clock cycle is #100
	#50;
	clk=0;
	#50;
     end

   initial begin
      #70;
      if (wave) begin
	 if(wave_delay) 
	   #(100*wave_delay);
	 $display("%t:\tStarting signal and memory wave capture",$time);
	 $vcdpluson(0,        top);
         //         levels  instance
      end
   end
   

   initial begin
      $display("%t: TESTBENCH IS ALIVE -- STARTING INITIALIZATION...",$time);
      // some simulation control initialization
      get_command_line_args();
      dummy = $urandom(seed);
      TransGenA = new();
      TransGenB = new();
      TransGenC = new();
      TransRes = new();
      GoldRef = new();
      //; if ($enable_forwarding eq 'YES'){
      `$forward_A->iname()` = new();
      `$forward_B->iname()` = new();
      `$forward_C->iname()` = new();
      //; }

      $display("%t: TESTBENCH IS ALIVE (SEED=%d) -- NOW RUNNING %d TESTS...", $time, seed, num_trans);
      // some simulation wire values initialization
      dumptolog = 1'b0;
      valid_in = 1'b0;
      reset=1'b1;
      a = 0;
      b = 0;
      c = 0;
      rnd = 3'b0;
      //; if ($enable_forwarding eq 'YES'){
      forward_a = 1'b0;
      forward_b = 1'b0;
      forward_c = 1'b0;
      //; }
      #150; // 2 cycles of reset
      reset=1'b0;
   end

   // every #(70+100*k), generate stimulus	
   initial begin
      #270;
      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 int i=0;
	 while (i<num_trans) begin
	    if(!stall_request) begin
	       valid_in = 1'b1;
	       i++;
	       // Assign values to the lines
	       dumptolog = 1'b0;
	       //; if ($enable_forwarding eq 'YES'){
	       `$forward_A->iname()`.randomize();
	       `$forward_B->iname()`.randomize();
	       `$forward_C->iname()`.randomize();
	       
	       if ( `$forward_A->iname()`.forward
		    // check the if there is result in pipeline for forwarding
		    && expected_q.size() >= `$forward_cycle_a` ) begin
		  forward_a = 1'b1;
		  a = expected_q[`$pipeline_depth-$forward_cycle_a-1`];
		  //; for (my $i=0; $i<$forward_cycle_a; $i++){
		  //$display("%t expected_q[`$i`] = %h", $time, expected_q[`$i`]);
		  //;}
		  TransGenA.ForceSignExpFrac(a[`$fp_width-1`], a[`$fp_width -2`:`$frac_width`], a[`$frac_width -1`:0], 1'b0);
	       end 
	       else  begin
		  forward_a = 1'b0;
		  TransGenA.randomize();
		  a[`$exp_width + $frac_width`] = TransGenA.Sign;
		  a[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenA.Exponent;
		  a[`$frac_width -1`:0] = TransGenA.Fraction;
	       end // else: !if( `$forward_A->iname()`.forward...
	       // store the forward_a signal in the queue
	       forward_a_q = {forward_a_q, forward_a};
	       
	       if ( `$forward_B->iname()`.forward
		    // check the if there is result in pipeline for forwarding
		    && expected_q.size() >= `$forward_cycle_b` ) begin
		  forward_b = 1'b1;
		  b = expected_q[`$pipeline_depth-$forward_cycle_b-1`];	       
		  TransGenB.ForceSignExpFrac(b[`$fp_width-1`], b[`$fp_width -2`:`$frac_width`], b[`$frac_width -1`:0], 1'b0);
	       end 
	       else  begin
		  forward_b = 1'b0;
		  TransGenB.randomize();
		  b[`$exp_width + $frac_width`] = TransGenB.Sign;
		  b[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenB.Exponent;
		  b[`$frac_width -1`:0] = TransGenB.Fraction;
	       end // else: !if( `$forward_B->iname()`.forward...
	       // store the forward_b signal in the queue
	       forward_b_q = {forward_b_q, forward_b};
	       
	       if ( (|`$forward_C->iname()`.forward)
		    // check the if there is result in pipeline for forwarding
		    && expected_q.size() >= `$forward_cycle_c` ) begin
		  forward_c = `$forward_C->iname()`.forward;
		  c = expected_q[`$pipeline_depth-$forward_cycle_c-1`+`$forward_C->iname()`.hotbit];	       
		  TransGenC.ForceSignExpFrac(c[`$fp_width-1`], c[`$fp_width -2`:`$frac_width`], c[`$frac_width -1`:0], 1'b0);
	       end 
	       else  begin
		  forward_c = 'b0;
		  TransGenC.randomize();
		  c[`$exp_width + $frac_width`] = TransGenC.Sign;
		  c[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenC.Exponent;
		  c[`$frac_width -1`:0] = TransGenC.Fraction;
	       end // else: !if( `$forward_C->iname()`.forward...
	       // store the forward_a signal in the queue
	       forward_c_q = {forward_c_q, forward_c};
	       //; } else {
	       TransGenA.randomize();
	       a[`$exp_width + $frac_width`] = TransGenA.Sign;
	       a[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenA.Exponent;
	       a[`$frac_width -1`:0] = TransGenA.Fraction;
	       TransGenB.randomize();
	       TransGenC.randomize();
	       b[`$exp_width + $frac_width`] = TransGenB.Sign;
	       b[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenB.Exponent;
	       b[`$frac_width -1`:0] = TransGenB.Fraction;
	       c[`$exp_width + $frac_width`] = TransGenC.Sign;
	       c[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenC.Exponent;
	       c[`$frac_width -1`:0] = TransGenC.Fraction;
	       //;}
	       GoldRef.CalcGold(TransGenA, TransGenB, TransGenC, rnd);
	       expected[`$exp_width + $frac_width`] = GoldRef.Expected.Sign;
	       expected[`$exp_width + $frac_width -1`:`$frac_width`] = GoldRef.Expected.Exponent;
	       expected[`$frac_width -1`:0] = GoldRef.Expected.Fraction;
	       a_q = {a_q, a};
	       b_q = {b_q, b};
	       c_q = {c_q, c};
	       expected_q = {expected_q, expected};
	    end
	    #100;		// wait a clock cycle
    	 end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	 $readmemh (vector_file, Memory);
	 loc=0;
	 Temp = Memory[loc];
	 Temp_q = {Temp_q, Temp};
	 while((loc < MEM_SIZE) && !(Temp == 1'bx) ) begin
	    valid_in = 1'b1;
	    rnd = Temp[`$fp_width*4+20+1`:`$fp_width*4+20`];
	    a = Temp[`$fp_width*4+20-1`:`$fp_width*3+20`];
	    b = Temp[`$fp_width*3+20-1`:`$fp_width*2+20`];
	    c = Temp[`$fp_width*2+20-1`:`$fp_width  +20`];	    
	    loc = loc + 1;
	    #100;
	    Temp = Memory[loc];
	    Temp_q = {Temp_q, Temp};
	 end // while (loc <MEM_SIZE && MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
   end // initial begin
   
   
   // every #(230+100*$pipeline_depth+100*k), check results	
   initial begin
      #`230+100*$pipeline_depth`;
      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 int i=0;
	 while (i<num_trans) begin
	    if(!stall_request) begin
	       i++;
	       
	       $display("\n%t: Transaction #%0d: ", $time, i);
	       r_a = a_q[0];
	       r_b = b_q[0];
	       r_c = c_q[0];
	       r_expected = expected_q[0];
	       a_q = a_q[1:$];
	       b_q = b_q[1:$];
	       c_q = c_q[1:$];
	       expected_q = expected_q[1:$];
	       TransRes.ForceSignExpFrac(z[`$exp_width + $frac_width`],
					 z[`$exp_width + $frac_width -1`:`$frac_width`],
					 z[`$frac_width -1`:0],
					 zinc);
	       TransGenA.ForceSignExpFrac(r_a[`$fp_width-1`], r_a[`$fp_width -2`:`$frac_width`], r_a[`$frac_width -1`:0], 1'b0);
	       TransGenB.ForceSignExpFrac(r_b[`$fp_width-1`], r_b[`$fp_width -2`:`$frac_width`], r_b[`$frac_width -1`:0], 1'b0);
	       TransGenC.ForceSignExpFrac(r_c[`$fp_width-1`], r_c[`$fp_width -2`:`$frac_width`], r_c[`$frac_width -1`:0], 1'b0);

	       //; if ($enable_forwarding eq 'YES'){
	       // Print the forwarding information
	       if ( forward_a_q[0] )
		 $display("%t A is forwarded from Transaction #%0d cycles before", $time, i-`$forward_cycle_a`);
	       if ( forward_b_q[0] )
		 $display("%t B is forwarded from Transaction #%0d cycles before", $time, i-`$forward_cycle_b`);
	       if ( |forward_c_q[0] ) begin
		int hotbit;
		for (int k=0; k<=`$mul_pipeline_depth`; k++) begin
			if (forward_c_q[0][k]) hotbit=k;
		end
		 $display("%t C is forwarded from Transaction #%0d cycles before", $time, i-`$forward_cycle_c`+hotbit);
		end
	       forward_a_q = forward_a_q[1:$];
	       forward_b_q = forward_b_q[1:$];
	       forward_c_q = forward_c_q[1:$];
	       //; }
	       // now check results... 
	       if (! GoldRef.CheckMultResult(TransRes, TransGenA, TransGenB, TransGenC, rnd))
		  
		 begin
		    dumptolog = 1'b1;
		    #1;
		    $display("%t: \033[0;31mERROR Found\033[0m", $time);
		    $finish(2);
		 end
	       else begin
		  $display("%t: %hx%h+%h = %h (%h) Checked", $time, r_a, r_b, r_c, z, r_expected);
	       end // else: !if(! GoldRef.CheckMultResult(TransRes, TransGenA, TransGenB, TransGenC, rnd))
	    end
	    #100;		// wait a clock cycle
    	 end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	 r_Temp = Temp_q[0];
  	 Temp_q = Temp_q[1:$];
	 while( !(r_Temp == 1'bx) ) begin
	    
	    expectZ = r_Temp[`$fp_width+20-1`:20];
	    FO = r_Temp[12];
	    FZ = r_Temp[0];
	    FV = r_Temp[4];
	    FU = r_Temp[8];
	    FX = r_Temp[16];
	    r_rnd = r_Temp[`$fp_width*4+20+1`:`$fp_width*4+20`];
	    r_a = r_Temp[`$fp_width*4+20-1`:`$fp_width*3+20`];
	    r_b = r_Temp[`$fp_width*3+20-1`:`$fp_width*2+20`];
	    r_c = r_Temp[`$fp_width*2+20-1`:`$fp_width  +20`];
	    expectNaN = expectZ[`$fp_width-2`:`$frac_width`] ==	{(`$exp_width`){1'b1}} 
			&& expectZ[`$frac_width-1`:0]!={(`$frac_width`){1'b0}};
	    expectIsZero = expectZ[`$fp_width-2`:`$frac_width`] == {(`$exp_width`){1'b0}} 
			   && expectZ[`$frac_width-1`:0]=={(`$frac_width`){1'b0}};
	    
	    /*
	     if(FO) begin
	     expectZ[`$fp_width-2`:0] = {{(`$exp_width`){1'b1}},{(`$frac_width`){1'b0}}};
	    end
	     if(FU) begin
	     expectZ[`$fp_width-2`:0] = {(`$exp_width+$frac_width`){1'b0}};
	    end
	     */


            $display("%t: Input: %h_%h_%h_%h ( %e * %e + %e = %e )", $time,
		     r_rnd, r_a, r_b, r_c, $bitstoreal(r_a),  $bitstoreal(r_b), $bitstoreal(r_c), $bitstoreal(expectZ));
	    // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
            $display("%t: Expect Result: Sign = %h, Exp = %h, Man = %h, FO=%h FU=%h FV=%h FX=%h FZ=%h, NaN=%b", $time,
		     expectZ[`$fp_width-1`], expectZ[`$fp_width-2`:`$frac_width`], expectZ[`$frac_width-1`:0],FO, FU, FV, FX, FZ, expectNaN);
            $display("%t: FMA_Result: Sign = %h, Exp = %h, Man = %h, Inc=%h", $time,
		     z[`$fp_width-1`], z[`$fp_width-2`:`$frac_width`], z[`$frac_width-1`:0], zinc);
	    //calculate output result after inc
    	    TransRes.ForceSignExpFrac(z[`$fp_width-1`], z[`$fp_width -2`:`$frac_width`], z[`$frac_width -1`:0], zinc);
	    TransRes.CalculateInc();
	    z2 = TransRes.GetFPNum();
            $display("%t: After Inc: Sign = %h, Exp = %h, Man = %h  ", $time,
		     z2[`$fp_width-1`], z2[`$fp_width-2`:`$frac_width`], z2[`$frac_width-1`:0] );
	    resultIsZero = z2[`$fp_width-2`:`$frac_width`] == {(`$exp_width`){1'b0}} 
			   && z2[`$frac_width-1`:0]=={(`$frac_width`){1'b0}};
	    if(!(z2 == expectZ || (resultIsZero==1 && expectIsZero==1)/* && !(FO==1 && status[1]==1) && !(FU==1 && (status[0]|status[3]==1))*/|| (expectNaN==1 && (status[2]==1)))) begin
	       dumptolog = 1'b1;
	       #1;
	       $display("%t: \033[0;31mERROR Found\033[0m", $time);
	       $finish(2);
	    end
	    #100;
	    r_Temp = Temp_q[0];
  	    Temp_q = Temp_q[1:$];
	 end // while ( MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
      #1000; // give the lines some time to settle
      $display("%t: TESTBENCH IS DONE -- \033[0;32mTEST PASS\033[0m", $time);
      $finish(0);
   end // initial begin


   
   //-------------------------------------------------------------------------//
   // general intialization procedure
   task get_command_line_args;
      // if this is a "+wave" run, it must record all signals
      if ( $test$plusargs("Wave") ) 
	begin
           $display("%t:\tRuntime input Wave found (starting signal and memory wave capture)",$time);
	   wave = 1;
	end
      if ( $test$plusargs("WaveDelay") ) 
	begin
	   $value$plusargs("WaveDelay=%d", wave_delay);
	   $display("%t:\tRuntime input +DelayWave=%0d found. Waveform will be recorded from the %0dth Transaction",$time, wave_delay, wave_delay);
	end
      // find the seed for this run
      if ( $test$plusargs("Seed") ) 
	begin
	   $value$plusargs("Seed=%d", seed);
	   $display("%t:\tRuntime input +Seed=%d found",$time, seed);
	end
      if ( $test$plusargs("NumTrans") )
	begin
	   $value$plusargs("NumTrans=%d", num_trans);
	   $display("%t:\tRuntime input +NumTrans=%d found",$time, num_trans);
	end
      if ( $test$plusargs("File") )
	begin
	   $value$plusargs("File=%s", vector_file);
	   $display("%t:\tRuntime input +File=%s found",$time, vector_file);
	end
   endtask // get_command_line_args
   
   
endprogram : `mname`
