/* *****************************************************************************
 * Description:
 * Top module for simulation, used for simple FMA module testing. Should not
 * be mistaken as a full fledged verification environment. It's not!
 * 
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Feb 04, 2012  jingpu    init version - change original top module to FMA verif
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off." ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.");
//; my $SAIF_mode = parameter(Name=>'SAIF_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"SAIF mode determines whether or not ".
//;                                 "special activity factor exraction. ".
//;                                 "is attempted");
//;  ( $SAIF_mode eq 'ON' and $synth_mode eq 'OFF' ) and $self->error( "Please do not attempt SAIF extraction in SYNTH=OFF mode\n" ); 
//;  ( $verif_mode eq 'ON' and $synth_mode eq 'ON' ) and $self->error( "Please do not attempt synth in VERIF=ON mode\n" ); 
//;  

module `mname` ();   
   //; # Generate the DUT here
   //; my $FP_obj = generate('FMA', 'FMA');

   //; # Read what kind of DUT the user wanted so you can test it
   //; my $frac_width = $FP_obj->get_param('FractionWidth');
   //; my $exp_width = $FP_obj->get_param('ExponentWidth');
   //; my $pipeline_depth = $FP_obj->get_param('PipelineDepth');
   //; my $enable_forwarding = $FP_obj->get_param('EnableForwarding');
   //; my $enable_denormals = $FP_obj->get_param('EnableDenormals');
   //; my $product_width = 2 * $frac_width + 2;
  
   // local signals for driving inputs
   logic [`$exp_width + $frac_width`:0] a, b, c;
   //; if ($enable_forwarding =~ /YES/){
   logic forward_a, forward_b, forward_c;
   //; }
   logic [2:0] rnd;

   
   // local signals for observing outputs
   logic [`$exp_width + $frac_width`:0] z;
   logic [7:0] status;

   // local signals for pipeline control
   logic clk, reset;
   //; if ($pipeline_depth>0){
   logic stall, SI, SCAN_ENABLE, test_mode, SO, valid_out;
   //; }
						  
   //; if ($verif_mode =~ /ON/){
   logic 				      dumptolog;
   //; }
   
   // Instantiate the dut here
   `$FP_obj->instantiate()` (
			     // inputs:
			     //; if ($verif_mode =~ /ON/){
			     .dumptolog(dumptolog),
			     //; }
			     .a(a), .b(b), .c(c), .rnd(rnd),
                             //; if ($enable_forwarding =~ /YES/){
                             .forward_a(1'b0), .forward_b(1'b0), .forward_c(1'b0),
                             //; }
   			     //; if ($pipeline_depth>0){
                             .clk(clk), .reset(reset), .valid_in(1'b1), .stall(1'b0),
			     .SCAN_ENABLE(SCAN_ENABLE), .test_mode(test_mode),
                             .SO(SO), .SI(SI), .valid_out(valid_out),
   		             //; } else {
 			     .clk(clk), .reset(reset),
                             //; }
			     //outputs:
			     .z(z), .status(status)
			     );
   
   
   //; if ($verif_mode =~ /ON/){
   // ------------------------ VERIFICATION HARNES ---------------------------//
   // Instantiate the TestGenerator here:
   //; my $TestBench_obj = generate('TestBench_FMA', 'TestBench', 
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width,
   //;                              PipelineDepth=>$pipeline_depth,
   //; 				    UseInc=>'NO',
   //;                              TestDenormals=>$enable_denormals);
   `$TestBench_obj->instantiate` (
				// outputs:
				.dumptolog(dumptolog),
				.a(a), .b(b), .c(c), .rnd(rnd),
   			     	//; if ($pipeline_depth>0){
                            	.clk(clk), .reset(reset),
			     	.stall_pipeline(stall_pipeline),  .SCAN_ENABLE(SCAN_ENABLE), .test_mode(test_mode),
                             	.SO(SO), .SI(SI),
   		            	 //; } else {
 			    	 .clk(clk), .reset(reset),
                            	 //; }
				// inputs
				.z(z), .zinc(zinc), .status(status)
				);
   //; } # End of "if ($verif_mode..."


   //; if ($verif_mode eq "OFF"){
   //; if ($synth_mode eq "ON"){
   //; if ($SAIF_mode  eq "ON"){

          int clk_period;
          int seed;
       
   
          //YAY for CLOCK
          initial begin
	     int clk_half_period;
	     real clk_period_ns;
	     seed = 500 ;
	     
	     if ( $test$plusargs("clk_period") ) 
	       begin
		  $value$plusargs("clk_period=%g",clk_period_ns);
		  clk_period = $rtoi(clk_period_ns*1000.0) ;
		  clk_half_period = clk_period / 2 ;
		  $display( "Using Clk Period= %f nS", clk_period_ns) ;
		  $display( "Using Clk Period= %d pS", clk_period) ;
		  if( clk_period < 100 ) begin
		     $display( "Error: Clock Period too small, Try again" );
		     $finish(2);
		  end
	       end else begin
		  $display( "ERROR: No Clock Period Set, Try again") ;
		  $finish(2);
	       end
	     while(1) begin
		#clk_half_period clk = 1'b0 ;
		#clk_half_period clk = 1'b1 ;
	     end
	  end // initial begin

          //YAY for RESET
          initial begin
             reset = 1'b1 ;
             #clk_period ;
             #clk_period ;
             #clk_period ;
             #clk_period ; 
             reset = 1'b0 ;
	  end

          //YAY for Driver
          assign rnd = 3'b0 ;
          assign ainc = 1'b0 ;
          assign binc = 1'b0 ;
          assign cinc = 1'b0 ;

//; my $j_rand = "{ \$random(seed) , \$random(seed) , \$random(seed) , \$random(seed) }" ;
   
          //YAY for Driver
          initial begin
	     
             int i;
             a = `$j_rand` ;
             b = `$j_rand` ;
             c = `$j_rand` ;
	     repeat (20) @(posedge clk);#1;

	     //Start Toggle Extraction
	     $set_gate_level_monitoring("rtl_on");
	     #1
	     $set_toggle_region(top_FMA);
	     #1
	     $toggle_start(); 
	     #1
	     $display("%t: AGENT IS ALIVE -- NOW RUN For Extraction...", $time);

	     for (i=0; i<100000; i++) begin
		a = `$j_rand` ;
		b = `$j_rand` ;
		c = `$j_rand` ;
		@(negedge clk);
	     end

	     $display("%t: AGENT IS DONE", $time);
	     repeat (20) @(posedge clk);

	     $toggle_stop();
	     $toggle_report ("top.saif",1.0e-12,top_FMA);
	     $finish(2);
	     
	  end
	     
//   logic [`$exp_width + $frac_width`:0] a, b, c;
   
//   logic clk, reset;
//   //; if ($pipeline_depth>0){
//   logic stall_pipeline, SI, SCAN_ENABLE, test_mode, SO;
//   //; }
           

   
   
   //;
   //; }}}
   
endmodule : `mname`
