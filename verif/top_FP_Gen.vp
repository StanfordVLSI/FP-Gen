/* *****************************************************************************
 * Description:
 * Top module for simulation, used for simple FMA module testing. Should not
 * be mistaken as a full fledged verification environment. It's not!
 * 
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Feb 04, 2012  jingpu    init version - change original top module to FMA verif
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off." ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.");
//; my $SAIF_mode = parameter(Name=>'SAIF_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"SAIF mode determines whether or not ".
//;                                 "special activity factor exraction. ".
//;                                 "is attempted");
//;  ( $SAIF_mode eq 'ON' and $synth_mode eq 'OFF' ) and $self->error( "Please do not attempt SAIF extraction in SYNTH=OFF mode\n" ); 
//;  ( $verif_mode eq 'ON' and $synth_mode eq 'ON' ) and $self->error( "Please do not attempt synth in VERIF=ON mode\n" ); 
//;  

module `mname` ();   
   //; # Generate the DUT here and get the pipeline depth
   //; my $FP_obj               = generate('FP_Gen', 'FP_Gen', VERIF_MODE=>$verif_mode , SYNTH_MODE=>$synth_mode );
   //; my $arch                 = $FP_obj->get_param('Architecture');
   //; my $pipeline_depth       = $FP_obj->get_param('PipelineDepth');
   //; my $mul_pipeline_depth   = $FP_obj->get_param('MulPipelineDepth') ;
   //; my $add_pipeline_depth   = $FP_obj->get_param('AddPipelineDepth');
   //; my $frac_width           = $FP_obj->get_param('FractionWidth');
   //; my $exp_width            = $FP_obj->get_param('ExponentWidth');
   //; my $enable_forwarding    = $FP_obj->get_param('EnableForwarding');
   //; my $enable_denormals     = $FP_obj->get_param('EnableDenormals');
   //; my $product_width        = 2 * $frac_width + 2;


   //; ##############################################################
   //; ### Local Signals to Stitch the Bench to the DUT
   //; ##############################################################
   

//; ##### Verification Signals #####		       
//; if ($verif_mode =~ /ON/){
	  logic 				     dumptolog;
//; }		

//; ##### INPUTS ######
          logic [`$exp_width + $frac_width`:0]  a;
          logic [`$exp_width + $frac_width`:0]  b;
          logic [`$exp_width + $frac_width`:0]  c;
	  logic [2:0] 			        rnd;		

          logic 				     stall_in;
		
//; ##### Inputs For Forwarding #####
//; if ($enable_forwarding =~ /YES/){
          logic 				     forward_a; 
          logic 				     forward_b; 
          logic [`$mul_pipeline_depth`:0]            forward_c;
//; }
		
//; ##### Inputs For Piped Design #####
//; if ($pipeline_depth>0){
          logic 				     valid_in; 
          logic 				     SI; 
//; }    

//; ##### GLOBALS ######
          logic 				     clk; 
          logic 				     reset;

		
//; ##### Globals For Piped Design #####
//;if ($pipeline_depth>0){
          logic 				     SCAN_ENABLE; 
          logic 				     test_mode;
//; }    
		       		
//; ##### Outputs for Piped Design #####
//;if ($pipeline_depth>0){
          logic 				     valid_out; 
          logic 				     SO;
//; }    
		       
//; ##### Outputs ##### 
          logic 				     stall_request;
	  logic [`$exp_width + $frac_width`:0] z;
	  logic [7:0] 			     status;



		         
   //; #######################################################################
   //; ### Instantiate Floating Point Multiply Add Unit as DEVICE UNDER TEST
   //; #######################################################################

   
   `$FP_obj->instantiate()` (
//;                           ###### Inputs ######		
//;                           if ($verif_mode =~ /ON/){
	   				                  .dumptolog(dumptolog),
//;                           }		
                                                          .a(a),
                                                          .b(b),
                                                          .c(c),
			                                  .rnd(rnd),
                                                          .stall_in(stall_in),		
//;                           if ($enable_forwarding =~ /YES/){
           				                 .forward_a(forward_a), 
           				                 .forward_b(forward_b), 
           				                 .forward_c(forward_c),
//;                           }
//;                           ###### GLOBALS ######		
//;                           if ($pipeline_depth>0){
           				                 .valid_in(valid_in), 
                                                         .SI(SI), 
//;                           }    
           				                 .clk(clk), 
           				                 .reset(reset), 
//;                           if ($pipeline_depth>0){
           				                 .SCAN_ENABLE(SCAN_ENABLE), 
            				                 .test_mode(test_mode),
//;                           }
//;                           ###### OUTPUTS ######    	       		
//;                           if ($pipeline_depth>0){
           				                 .valid_out(valid_out), 
           				                 .SO(SO),
//;                           }    
                                                         .stall_request(stall_request),  
	                                                 .z(z),
	   			                         .status(status)			     
			     );







   
   //; #######################################################################
   //; ### Begin Verification Framework
   //; #######################################################################

   
   
   //; if ($verif_mode =~ /ON/){
   // ------------------------ VERIFICATION HARNES ---------------------------//
   // Instantiate the TestGenerator here:
   //; my $TestBench_obj = generate('TestBench_MulAdd', 'TestBench',
   //;                              Architecture=>($arch eq 'FMA' ? 'Fused' : 'Cascade'),
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width,
   //;                              EnableForwarding=>$enable_forwarding,
   //;                              PipelineDepth=>$pipeline_depth,
   //;                              MulPipelineDepth=> $mul_pipeline_depth,
   //; 				    UseInc=>'NO',
   //;                              TestDenormals=>$enable_denormals);
   `$TestBench_obj->instantiate` (
				  // outputs:
				  .dumptolog(dumptolog),
				  .a(a), .b(b), .c(c), .rnd(rnd),
				  //; if ($enable_forwarding =~ /YES/){
				  .forward_a(forward_a), .forward_b(forward_b), .forward_c(forward_c),
				  //; }
   			     	  //; if ($pipeline_depth>0){
                            	  .clk(clk), .reset(reset),
			     	  .stall_pipeline(stall_pipeline),  .SCAN_ENABLE(SCAN_ENABLE), .test_mode(test_mode),
                             	  .SO(SO), .SI(SI),.valid_in(valid_in), .stall_in(stall_in),
   		            	  //; } else {
 			    	  .clk(clk), .reset(reset),
                            	  //; }
				  // inputs
				  .z(z),  .status(status), .valid_out(valid_out), .stall_request(stall_request)
				  );
   //; } # End of "if ($verif_mode..."


   //; #######################################################################
   //; ### Begin Activity Factor Estimation Framework
   //; #######################################################################
   
   //; if ($verif_mode eq "OFF"){
   //; if ($synth_mode eq "ON"){
   //; if ($SAIF_mode  eq "ON"){

          int clk_period;
          int seed;
       
          //YAY for CLOCK
          initial begin
	     int clk_half_period;
	     real clk_period_ns;
	     seed = 500 ;
	     
	     if ( $test$plusargs("clk_period") ) 
	       begin
		  $value$plusargs("clk_period=%g",clk_period_ns);
		  clk_period = $rtoi(clk_period_ns*1000.0) ;
		  clk_half_period = clk_period / 2 ;
		  $display( "Using Clk Period= %f nS", clk_period_ns) ;
		  $display( "Using Clk Period= %d pS", clk_period) ;
		  if( clk_period < 100 ) begin
		     $display( "Error: Clock Period too small, Try again" );
		     $finish(2);
		  end
	       end else begin
		  $display( "ERROR: No Clock Period Set, Try again") ;
		  $finish(2);
	       end
	     while(1) begin
		#clk_half_period clk = 1'b0 ;
		#clk_half_period clk = 1'b1 ;
	     end
	  end // initial begin

          //YAY for RESET
          initial begin
             reset = 1'b1 ;
             #clk_period ;
             #clk_period ;
             #clk_period ;
             #clk_period ; 
             reset = 1'b0 ;
	  end

          //YAY for Driver
          assign rnd = 3'b0 ;
          assign stall_in = 1'b0 ;
          assign forward_a = 0 ;
          assign forward_b = 0 ;
          assign forward_c = 0 ;
          assign valid_in = 1 ;
   
   
//; my $j_rand = "{ \$random(seed) , \$random(seed) , \$random(seed) , \$random(seed) }" ;
   
          //YAY for Driver
          initial begin
	     
             int i;
             a = `$j_rand` ;
             b = `$j_rand` ;
             c = `$j_rand` ;
	     repeat (20) @(posedge clk);#1;

	     //Start Toggle Extraction
	     $set_gate_level_monitoring("rtl_on");
	     #1
	     $set_toggle_region(top_FP_Gen);
	     #1
	     $toggle_start(); 
	     #1
	     $display("%t: AGENT IS ALIVE -- NOW RUN For Extraction...", $time);

	     for (i=0; i<10000; i++) begin
		a = `$j_rand` ;
		b = `$j_rand` ;
		c = `$j_rand` ;
		//$display("%t: x%h", $time , z );
		@(negedge clk);
	     end

	     $display("%t: AGENT IS DONE", $time);
	     repeat (20) @(posedge clk);

	     $toggle_stop();
	     $toggle_report ("top.saif",1.0e-12,top_FP_Gen);
	     $finish(2);
	     
	  end
	     

   //; }}}
   
endmodule : `mname`
