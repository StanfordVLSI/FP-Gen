/* *****************************************************************************
 * Description:
 * Top module for simulation, used for simple FMA module testing. Should not
 * be mistaken as a full fledged verification environment. It's not!
 * 
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Feb 04, 2012  jingpu    init version - change original top module to FMA verif
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; my $verif_mode = parameter(Name=>'VERIF_MODE',
//;                            Val=>'ON', List=>['ON','OFF'],
//;                            Doc=>"Verification mode determines whether or not ".
//;                                 "monitors and drivers are on. Possible values ".
//;                                 "are ON or Off." ); 
//; my $synth_mode = parameter(Name=>'SYNTH_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"Synthesis mode determines whether or not ".
//;                                 "special synthesis constructs are used. ".
//;                                 "Possible values are ON or Off.");
//; my $SAIF_mode = parameter(Name=>'SAIF_MODE',
//;                            Val=>'OFF', List=>['ON','OFF'],
//;                            Doc=>"SAIF mode determines whether or not ".
//;                                 "special activity factor exraction. ".
//;                                 "is attempted");
//; my $arch = parameter(Name=>'Architecture', Val=>'Cascade', List=>['Cascade', 'Fused'],
//; 			 Doc=>"Which architecture is tested? Cascaded multiply accumulate ".
//; 			      "or Fused? (Pick:Cascade/Fused)");
//;  ( $SAIF_mode eq 'ON' and $synth_mode eq 'OFF' ) and $self->error( "Please do not attempt SAIF extraction in SYNTH=OFF mode\n" ); 
//;  ( $verif_mode eq 'ON' and $synth_mode eq 'ON' ) and $self->error( "Please do not attempt synth in VERIF=ON mode\n" ); 
//;  

module `mname` ();   
   //; # Generate the DUT here and get the pipeline depth
   //; my $FP_obj;
   //; my $pipeline_depth;
   //; my $mul_pipeline_depth = 0;
   //; my $add_pipeline_depth;
   //; if ($arch eq 'Fused') {
   //;    $FP_obj = generate('FMA', 'FMA');
   //;    $pipeline_depth = $FP_obj->get_param('PipelineDepth');
   //; } else {  # $arch eq 'Cascade'
   //;    $FP_obj = generate('CMA', 'CMA');
   //;    $mul_pipeline_depth = $FP_obj->get_param('MulPipelineDepth');
   //;    $add_pipeline_depth = $FP_obj->get_param('AddPipelineDepth');
   //;    if ($mul_pipeline_depth>0) {
   //;       $pipeline_depth = $mul_pipeline_depth + $add_pipeline_depth + 1;
   //;    } else {  #$mul_pipeline_depth=0
   //;       $pipeline_depth = $add_pipeline_depth;
   //;    }
   //; }
   
   //; # Read what kind of DUT the user wanted so you can test it
   //; my $frac_width = $FP_obj->get_param('FractionWidth');
   //; my $exp_width = $FP_obj->get_param('ExponentWidth');
   //; my $enable_forwarding = $FP_obj->get_param('EnableForwarding');
   //; my $enable_denormals = $FP_obj->get_param('EnableDenormals');
   //; my $product_width = 2 * $frac_width + 2;
   
  
   // local signals for driving inputs
   logic [`$exp_width + $frac_width`:0] a, b, c;

   // forwarding control signals
   //; if ($enable_forwarding =~ /YES/){
   logic 				forward_a, forward_b;
   logic [`$mul_pipeline_depth`:0] 	forward_c;
   //; }
   logic [2:0] rnd;

   
   // local signals for observing outputs
   logic [`$exp_width + $frac_width`:0] z;
   logic [7:0] status;

   // local signals for pipeline control
   logic clk, reset, valid_in, stall_in;
   logic SI, SCAN_ENABLE, test_mode, SO;
   logic valid_out, stall_request;

						  
   //; if ($verif_mode =~ /ON/){
   logic 				      dumptolog;
   //; }
   
   // Instantiate the dut here
   `$FP_obj->instantiate()` (
			     // inputs:
			     //; if ($verif_mode =~ /ON/){
			     .dumptolog(dumptolog),
			     //; }
			     .a(a), .b(b), .c(c), .rnd(rnd),
                             //; if ($enable_forwarding =~ /YES/){
                             .forward_a(forward_a), .forward_b(forward_b),
			     //; if ($arch eq 'Cascade') {
			     .forward_c(forward_c),
			     //; } else {
			     .forward_c(forward_c[0]),
			     //; }
                             //; }
                             .clk(clk), .reset(reset),
   			     //; if ($pipeline_depth>0){
                             .valid_in(1'b1), .stall_in(1'b0),		     
			     .SCAN_ENABLE(SCAN_ENABLE), .test_mode(test_mode),
                             .SO(SO), .SI(SI), .valid_out(valid_out),
   		             //; }
			     //outputs:
			     //; if ($arch eq 'Cascade') {
			     .stall_request(stall_request),
			     //; }
			     .z(z), .status(status)
			     );
   
   //; if ($arch eq 'Fused') {
   assign stall_request = 1'b1;
   //; }
   
   //; if ($verif_mode =~ /ON/){
   // ------------------------ VERIFICATION HARNES ---------------------------//
   // Instantiate the TestGenerator here:
   //; my $TestBench_obj = generate('TestBench_MulAdd', 'TestBench',
   //;                              Architecture=>$arch,
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width,
   //;                              EnableForwarding=>$enable_forwarding,
   //;                              PipelineDepth=>$pipeline_depth,
   //;                              MulPipelineDepth=> $mul_pipeline_depth,
   //; 				    UseInc=>'NO',
   //;                              TestDenormals=>$enable_denormals);
   `$TestBench_obj->instantiate` (
				  // outputs:
				  .dumptolog(dumptolog),
				  .a(a), .b(b), .c(c), .rnd(rnd),
				  //; if ($enable_forwarding =~ /YES/){
				  .forward_a(forward_a), .forward_b(forward_b), .forward_c(forward_c),
				  //; }
   			     	  //; if ($pipeline_depth>0){
                            	  .clk(clk), .reset(reset),
			     	  .stall_pipeline(stall_pipeline),  .SCAN_ENABLE(SCAN_ENABLE), .test_mode(test_mode),
                             	  .SO(SO), .SI(SI),.valid_in(valid_in), .stall_in(stall_in),
   		            	  //; } else {
 			    	  .clk(clk), .reset(reset),
                            	  //; }
				  // inputs
				  .z(z),  .status(status), .valid_out(valid_out), .stall_request(stall_request)
				  );
   //; } # End of "if ($verif_mode..."


   //; if ($verif_mode eq "OFF"){
   //; if ($synth_mode eq "ON"){
   //; if ($SAIF_mode  eq "ON"){

          int clk_period;
          int seed;
       
   
          //YAY for CLOCK
          initial begin
	     int clk_half_period;
	     real clk_period_ns;
	     seed = 500 ;
	     
	     if ( $test$plusargs("clk_period") ) 
	       begin
		  $value$plusargs("clk_period=%g",clk_period_ns);
		  clk_period = $rtoi(clk_period_ns*1000.0) ;
		  clk_half_period = clk_period / 2 ;
		  $display( "Using Clk Period= %f nS", clk_period_ns) ;
		  $display( "Using Clk Period= %d pS", clk_period) ;
		  if( clk_period < 100 ) begin
		     $display( "Error: Clock Period too small, Try again" );
		     $finish(2);
		  end
	       end else begin
		  $display( "ERROR: No Clock Period Set, Try again") ;
		  $finish(2);
	       end
	     while(1) begin
		#clk_half_period clk = 1'b0 ;
		#clk_half_period clk = 1'b1 ;
	     end
	  end // initial begin

          //YAY for RESET
          initial begin
             reset = 1'b1 ;
             #clk_period ;
             #clk_period ;
             #clk_period ;
             #clk_period ; 
             reset = 1'b0 ;
	  end

          //YAY for Driver
          assign rnd = 3'b0 ;
          assign ainc = 1'b0 ;
          assign binc = 1'b0 ;
          assign cinc = 1'b0 ;

//; my $j_rand = "{ \$random(seed) , \$random(seed) , \$random(seed) , \$random(seed) }" ;
   
          //YAY for Driver
          initial begin
	     
             int i;
             a = `$j_rand` ;
             b = `$j_rand` ;
             c = `$j_rand` ;
	     repeat (20) @(posedge clk);#1;

	     //Start Toggle Extraction
	     $set_gate_level_monitoring("rtl_on");
	     #1
	     $set_toggle_region(top_MulAdd);
	     #1
	     $toggle_start(); 
	     #1
	     $display("%t: AGENT IS ALIVE -- NOW RUN For Extraction...", $time);

	     for (i=0; i<100000; i++) begin
		a = `$j_rand` ;
		b = `$j_rand` ;
		c = `$j_rand` ;
		@(negedge clk);
	     end

	     $display("%t: AGENT IS DONE", $time);
	     repeat (20) @(posedge clk);

	     $toggle_stop();
	     $toggle_report ("top.saif",1.0e-12,top_MulAdd);
	     $finish(2);
	     
	  end
	     

   //; }}}
   
endmodule : `mname`
