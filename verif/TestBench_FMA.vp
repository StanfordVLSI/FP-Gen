/* *****************************************************************************
 * Description:
 * -----------
 * TestBench for FMA
 * 
 * Runtime Arguments 
 * -----------------
 * (Via the "make run RUN=+<runtime_flag[=value]>" notation)
 * * Wave, Seed, NumTrans
 * 
 * Parameters:
 * -----------
 * * FractionWidth, ExponentWidth, Architecture, TestDenormals, UseInc
 * * NumTrans, Seed
 * 
 * 
 * Change bar:
 * -----------
 * Date          Author    Description
 * Oct 05, 2011  shacham   init version - test generator for FP Mult-Acc
 * 
 * ****************************************************************************/

/*******************************************************************************
 * PARAMETERIZATION
 * ****************************************************************************/
//; my $frac_width = parameter(Name=>'FractionWidth', Val=>52, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the signal for the multiplier (default is IEEE Double, 52 bit)");
//; my $exp_width = parameter(Name=>'ExponentWidth', Val=>11, 
//;                           Min=>4, Step=>1, 
//;                           Doc=>"Width of the signal for the multiplier (default is IEEE Double, 11 bit)");
//; my $vector_file = parameter(Name=>'TestVectorFile', Val=>'',
//;                             Doc=>"Name of the input testvector file");
//; my $arch = parameter(Name=>'Architecture', Val=>'Cascade', List=>['Cascade', 'Fused'],
//; 			 Doc=>"Which architecture is tested? Cascaded multiply accumulate ".
//; 			      "or Fused? (Pick:Cascade/Fused)");
//; my $test_denormals = parameter(Name=>'TestDenormals', Val=>'YES', 
//;                           List=>['YES','NO'], 
//;                           Doc=>"Enable denormals parameters to enable handling denormal values ".
//;                                "of inputs A and B correctly (YES/NO)");
//; my $pipeline_depth = parameter(Name=>'PipelineDepth', Val=>1, List=>[ 0,1,2,3,4,5,6,7 ] ,
//;                       Doc=>"Pipeline depth !FUNCTIONAL!");
//; my $useInc = parameter(Name=>'UseInc', Val=>'YES', List=>['YES', 'NO'],
//; 			   Doc=>"Pick 'NO' for A*B or pick 'YES' for (A+ainc)*(B+binc)");
//; my $num_trans = parameter(Name=>'NumTrans',Val=>10, Min=>1, Step=>1,
//;                           Doc=>"Number of test transactions to run ".
//;                                "(can be overriden at runtime using the '+NumTrans=value' command line notation)");
//; my $seed = parameter(Name=>'Seed',Val=>12345, Min=>0, Step=>1,
//;                      Doc=>"Seed for random values".
//;                      "(can AND SHOULD be overriden at runtime using the '+Seed=value' command line notation)");
//;                                 
//; my $product_width = 2 * $frac_width + 2; # (leading one + frac_w) *2;
//; my $fp_width = $frac_width + $exp_width + 1;

program automatic `mname` (
    output logic dumptolog,
			   // signals to drive the design
    output logic [`$exp_width + $frac_width`:0] a, b, c,
    output logic ainc, binc, cinc,
    output logic [2:0] rnd,			
   //; if ($pipeline_depth>0){
    output logic 				clk, reset, stall_pipeline, SI, SCAN_ENABLE, test_mode,
    input logic 				SO,
   //; } else {
    output logic 				clk, reset,
   //; }
			   // results from the design
    input logic [`$exp_width + $frac_width`:0] z,
    input logic zinc,
    input logic [7:0] status 
		);

   // Local variables and handles for controlling the simulation
   int 					seed=`$seed`;
   int 					num_trans = `$num_trans`;
   int 					dummy;
   string 				vector_file = "`$vector_file`";
   


   // Local variables and macros for controlling the input file and local memory
   parameter MEM_SIZE = 1000000;
   parameter MEM_WIDTH = 4+`$fp_width*4`+4+4+4+4+4;

   // Signals for the input testvector verification
   logic [MEM_WIDTH-1:0] Memory [0:MEM_SIZE-1];  // Space for input file
   logic [MEM_WIDTH-1:0] Temp, Temp_q[$], r_Temp;  // Verilog doesn't allow direct access to a
                           // bit field of an array
   logic [`$exp_width + $frac_width`:0] expectZ, z2;
   // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
   logic 				FX, FO, FU, FV, FZ,expectNaN;
   int 					loc;


   // Singals for pipeline output
   logic [`$exp_width + $frac_width`:0] r_a, r_b, r_c, a_q[$], b_q[$], c_q[$] ;
   logic 				r_ainc, ainc_q[$], r_binc, binc_q[$], r_cinc, cinc_q[$];
   logic [2:0] 				r_rnd;
   
 
   // FP transaction handles
   //; my $TransGenA_obj = generate('FPTransaction','TransGenA',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width,
   //; 				    Architecture=>$arch,
   //;                              TestDenormals=>$test_denormals);
   `$TransGenA_obj->instantiate`;
   //; my $TransGenB_obj = generate('FPTransaction','TransGenB',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>$arch,
   //;                              TestDenormals=>$test_denormals);
   `$TransGenB_obj->instantiate`;
   //; my $TransGenC_obj = generate('FPTransaction','TransGenC',
   //;				    Random=>'YES',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>'Fused', 
   //;                              TestDenormals=>$test_denormals);
   `$TransGenC_obj->instantiate`;

   // one more handle for the observed output
   //; my $TransRes_obj = generate('FPTransaction','TransRes',
   //;				    Random=>'NO',
   //;                              FractionWidth=>$frac_width, 
   //;                              ExponentWidth=>$exp_width, 
   //; 				    Architecture=>$arch,   
   //;                              TestDenormals=>$test_denormals);
   `$TransRes_obj->instantiate`;
   
   // Reference model
   //; my $GoldRef_obj = generate('GoldFMA', 'GoldRef', 
   //;                              FPTransA_Ptr=>$TransGenA_obj, 
   //;                              FPTransB_Ptr=>$TransGenB_obj,
   //;                              FPTransC_Ptr=>$TransGenC_obj,
   //;                              FPTransRes_Ptr=>$TransRes_obj,
   //;                              TestDenormals=>$test_denormals);
   `$GoldRef_obj->instantiate`;
   
   initial forever
    begin
      clk=1;	//clock cycle is #100
      #50;
      clk=0;
      #50;
    end

   initial begin
      $display("%t: TESTBENCH IS ALIVE -- STARTING INITIALIZATION...",$time);
      // some simulation control initialization
      get_command_line_args();
      dummy = $urandom(seed);
      TransGenA = new();
      TransGenB = new();
      TransGenC = new();
      TransRes = new();
      GoldRef = new();

      $display("%t: TESTBENCH IS ALIVE (SEED=%d) -- NOW RUNNING %d TESTS...", $time, seed, num_trans);
      // some simulation wire values initialization
      dumptolog = 1'b0;

      reset=1'b0;
      a = 0;
      b = 0;
      c = 0;
      ainc = 1'b0;
      binc = 1'b0;
      cinc = 1'b0;
      rnd = 3'b0;
   end

   // every #(70+100*k), generate stimulus	
   initial begin
      #70;
      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 for (int i=0; i<num_trans; i++) begin
	   // Assign values to the lines
	   dumptolog = 1'b0;
	   TransGenA.randomize();
	   TransGenB.randomize();
	   TransGenC.randomize();
	   a[`$exp_width + $frac_width`] = TransGenA.Sign;
	   a[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenA.Exponent;
	   a[`$frac_width -1`:0] = TransGenA.Fraction;
	   ainc = TransGenA.Inc;
	   b[`$exp_width + $frac_width`] = TransGenB.Sign;
	   b[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenB.Exponent;
	   b[`$frac_width -1`:0] = TransGenB.Fraction;
	   binc = TransGenB.Inc;
	   c[`$exp_width + $frac_width`] = TransGenC.Sign;
	   c[`$exp_width + $frac_width -1`:`$frac_width`] = TransGenC.Exponent;
	   c[`$frac_width -1`:0] = TransGenC.Fraction;
	   cinc = TransGenC.Inc;
	   a_q = {a_q, a};
	   b_q = {b_q, b};
	   c_q = {c_q, c};
	   ainc_q = {ainc_q, ainc};
	   binc_q = {binc_q, binc};
	   cinc_q = {cinc_q, cinc};
	   #100;		// wait a clock cycle
    	end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	$readmemh (vector_file, Memory);
	 loc=0;
	 Temp = Memory[loc];
	 Temp_q = {Temp_q, Temp};
	 while((loc < MEM_SIZE) && !(Temp == 1'bx) ) begin
	    rnd = Temp[`$fp_width*4+20+1`:`$fp_width*4+20`];
	    a = Temp[`$fp_width*4+20-1`:`$fp_width*3+20`];
	    b = Temp[`$fp_width*3+20-1`:`$fp_width*2+20`];
	    c = Temp[`$fp_width*2+20-1`:`$fp_width  +20`];	    
	    loc = loc + 1;
	    #100;
	    Temp = Memory[loc];
	    Temp_q = {Temp_q, Temp};
	    end // while (loc <MEM_SIZE && MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
   end // initial begin
   
   
   // every #(130+100*$pipeline_depth+100*k), check results	
   initial begin
      #`130+100*$pipeline_depth`;
      if (vector_file == "") begin   // if there is no input test file, then use our own transaction and gold model
	 for (int i=0; i<num_trans; i++) begin
	   $display("\n%t: Transaction #%0d: ", $time, i);
	   r_a = a_q[0];
	   r_b = b_q[0];
	   r_c = c_q[0];
	   r_ainc = ainc_q[0];
	   r_binc = binc_q[0];
	   r_cinc = cinc_q[0];
	   a_q = a_q[1:$];
	   b_q = b_q[1:$];
	   c_q = c_q[1:$];
	   ainc_q = ainc_q[1:$];
	   binc_q = binc_q[1:$];
	   cinc_q = cinc_q[1:$];
	   TransRes.ForceSignExpFrac(z[`$exp_width + $frac_width`],
				     z[`$exp_width + $frac_width -1`:`$frac_width`],
				     z[`$frac_width -1`:0],
				     zinc);
	   TransGenA.ForceSignExpFrac(r_a[`$fp_width-1`], r_a[`$fp_width -2`:`$frac_width`], r_a[`$frac_width -1`:0], r_ainc);
	   TransGenB.ForceSignExpFrac(r_b[`$fp_width-1`], r_b[`$fp_width -2`:`$frac_width`], r_b[`$frac_width -1`:0], r_binc);
	   TransGenC.ForceSignExpFrac(r_c[`$fp_width-1`], r_c[`$fp_width -2`:`$frac_width`], r_c[`$frac_width -1`:0], r_cinc);
	   GoldRef.CalcGold(TransGenA, TransGenB, TransGenC, rnd);
	   
	   // now check results... 
	   if (! GoldRef.CheckMultResult(TransRes))
	     begin
		dumptolog = 1'b1;
		#1;
		$display("%t: \033[0;31mERROR Found\033[0m", $time);
		$finish(2);
	     end
	   #100;		// wait a clock cycle
    	end // for (int i=0; i<num_trans; i++)
      end // if (vector_file == "")
      else begin // use the input test file
	 r_Temp = Temp_q[0];
  	 Temp_q = Temp_q[1:$];
	 while( !(r_Temp == 1'bx) ) begin
	    expectZ = r_Temp[`$fp_width+20-1`:20];
	    FO = r_Temp[12];
	    FZ = r_Temp[0];
	    FV = r_Temp[4];
	    FU = r_Temp[8];
	    FX = r_Temp[16];
	    r_rnd = r_Temp[`$fp_width*4+20+1`:`$fp_width*4+20`];
	    r_a = r_Temp[`$fp_width*4+20-1`:`$fp_width*3+20`];
	    r_b = r_Temp[`$fp_width*3+20-1`:`$fp_width*2+20`];
	    r_c = r_Temp[`$fp_width*2+20-1`:`$fp_width  +20`];
	    expectNaN = expectZ[`$fp_width-2`:`$frac_width`] == 
			{(`$exp_width`){1'b1}} && expectZ[`$frac_width-1`:0]!={(`$frac_width`){1'b0}};
	    
	    /*
	    if(FO) begin
	       expectZ[`$fp_width-2`:0] = {{(`$exp_width`){1'b1}},{(`$frac_width`){1'b0}}};
	    end
	    if(FU) begin
	       expectZ[`$fp_width-2`:0] = {(`$exp_width+$frac_width`){1'b0}};
	    end
	    */


            $display("%t: Input: %h_%h_%h_%h ( %e * %e + %e = %e )", $time,
		     r_rnd, r_a, r_b, r_c, $bitstoreal(r_a),  $bitstoreal(r_b), $bitstoreal(r_c), $bitstoreal(expectZ));
	    // X for inexact, O for overflow, U for underflow, V for invalid, and Z for zero-divide
            $display("%t: Expect Result: Sign = %h, Exp = %h, Man = %h, FO=%h FU=%h FV=%h FX=%h FZ=%h, NaN=%b", $time,
		     expectZ[`$fp_width-1`], expectZ[`$fp_width-2`:`$frac_width`], expectZ[`$frac_width-1`:0],FO, FU, FV, FX, FZ, expectNaN);
            $display("%t: FMA_Result: Sign = %h, Exp = %h, Man = %h, Inc=%h", $time,
		     z[`$fp_width-1`], z[`$fp_width-2`:`$frac_width`], z[`$frac_width-1`:0], zinc);
	    //calculate output result after inc
    	    TransRes.ForceSignExpFrac(z[`$fp_width-1`], z[`$fp_width -2`:`$frac_width`], z[`$frac_width -1`:0], zinc);
	    TransRes.CalculateInc();
	    z2 = TransRes.GetFPNum();
            $display("%t: After Inc: Sign = %h, Exp = %h, Man = %h  ", $time,
		     z2[`$fp_width-1`], z2[`$fp_width-2`:`$frac_width`], z2[`$frac_width-1`:0] );
	    if(z2 != expectZ/* && !(FO==1 && status[1]==1) && !(FU==1 && (status[0]|status[3]==1))&& !(expectNaN==1 && (status[2]==1))*/) begin
	       dumptolog = 1'b1;
	       #1;
	       $display("%t: \033[0;31mERROR Found\033[0m", $time);
	       $finish(2);
	    end
	    #100;
	    r_Temp = Temp_q[0];
  	    Temp_q = Temp_q[1:$];
	    end // while ( MemTemp !== 1b'x )
      end // else: !if(vector_file == "")
      #1000; // give the lines some time to settle
      $display("%t: TESTBENCH IS DONE -- \033[0;32mTEST PASS\033[0m", $time);
      $finish(0);
   end // initial begin


   
   //-------------------------------------------------------------------------//
   // general intialization procedure
   task get_command_line_args;
      // if this is a "+wave" run, it must record all signals
      if ( $test$plusargs("Wave") ) 
	begin
           $display("%t:\tRuntime input Wave found (starting signal and memory wave capture)",$time);
           //         levels  instance
           $vcdpluson(0,        top_FMA);
	   $vcdplusmemon(0,     top_FMA);
        end
      // find the seed for this run
      if ( $test$plusargs("Seed") ) 
	begin
	   $value$plusargs("Seed=%d", seed);
	   $display("%t:\tRuntime input +Seed=%d found",$time, seed);
	end
      if ( $test$plusargs("NumTrans") )
	begin
	   $value$plusargs("NumTrans=%d", num_trans);
	   $display("%t:\tRuntime input +NumTrans=%d found",$time, num_trans);
	end
      if ( $test$plusargs("File") )
	begin
	   $value$plusargs("File=%s", vector_file);
	   $display("%t:\tRuntime input +File=%s found",$time, vector_file);
	end
   endtask // get_command_line_args
   
      
endprogram : `mname`
